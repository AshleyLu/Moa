#!/usr/bin/env python

import os
import re
import sys
import gzip
import copy
import math
import time
import numpy as np
import cPickle
import random
import tarfile
import logging
import optparse
import tempfile
import subprocess as sp
import rpy2.robjects as robjects
import rpy2.robjects.numpy2ri

## INITIALIZE, VARIABLES, HELPER FUNCTIONS
VERSION = 0.1
random.seed()
r = robjects.r

colors = {
    'r' : '#E81717',
    'y' : '#EBCE17',
    'g' : '#42EB17',
    'b' : '#1972D1',
    'p' : '#A6219D',
    '0' : '#000000',
    '1' : '#333333',
    '2' : '#666666',
    '3' : '#999999',
    '4' : '#cccccc',
    }

#format text for optparse help
def _hf(s): return " ".join(s.split())

#introduce a slight variation into a color
def _colorVar(col):
    choices = list('000123456789ABCDEFFFF')
    cl = list(col.upper())
    for x in range(1, 7, 2):
        cl[x] = choices[choices.index(cl[x],2) + random.choice([-4, -2, 0, 2, 4])]
    res = "".join(cl)
    l.debug("changed color %s to %s" % (col, res))
    return res

################################################################################
## Define command line arguments

## Arguments: General options 
parser = optparse.OptionParser(version=VERSION)
parser.add_option('-s', dest='sequence', help='Input sequence to analyse')
parser.add_option('-v', dest='verbose', action="count", 
                  help='Show debug information')

parser.add_option('--bn', dest='basename',
                  help='base name of the output files. If not specified, it is derived ' +
                  'from the sequence name')

parser.add_option('--dataout', dest='dataOut', action='store_true',
                  help='output the processed (gzipped!) data to this file')

parser.add_option('--datain', dest='dataIn', action='store_true',
                  help='read program input from a data file')

## Arguments : Control image 
parser_i = optparse.OptionGroup(parser, "Image control")
parser.set_defaults(xsize="800", ysize="600", lineAlpha='55', xstart=0,
                    plotMode=[], grid=False, gridLines = 20,
                    gridColor = 'CCCCAA')

xsizeHelp = """ (pixels) X resolution of the graph. As an alternative
it is possible to define [VALUE]P (i.e. 1000P) in which case the width is
calculated based on the sequence length, with one pixel for each 1000 nt."""

parser_i.add_option('--noImage', dest='noimage',  help='skip image generation',
                    action='store_true')

parser_i.add_option('-x', dest='xsize', metavar='SIZE', help=_hf(xsizeHelp))

parser_i.add_option('-y', dest='ysize', type='int', metavar='SIZE',
                    help='(pixels) y resolution of the graph')

parser_i.add_option('--xstart', dest='xstart', type='int', metavar='POS',
                    help='(nt) start the graph at a certain position')

parser_i.add_option('--xstop', dest='xstop', type='int', metavar='POS',
                    help='(nt) end the graph at a certain position')

parser_i.add_option('--ymax', dest='ymax', type='int', metavar='POS',
                    help='(nt) max y value')

parser_i.add_option('--ymin', dest='ymin', type='int', metavar='POS',
                    help='(nt) min y value')

parser_i.add_option('--grid', dest='grid', action='store_true')
parser_i.add_option('--gridlines', dest='gridLines', type='int')
parser_i.add_option('--gridcolor', dest='gridColor')

parser_i.add_option('--lines', dest='drawLines', action='store_true',
                    help='Draw lines representing insert length')

plotMode_help = """ How to plot Bowtie data & simulated data. 'split:
split the graph in two. 'bs': One graph, plotting the simulated data
over the Bowtie data. 'sb': one graph, the other way round (default:
'bs'). 'yd' is a historgram of the insert size distribution"""

parser_i.add_option('--plotmode', dest='plotMode', metavar='MODE',
                    help=_hf(plotMode_help), action='append')

parser_g = optparse.OptionGroup(parser, "Simulate readpairs")
parser.set_defaults(maxInsertSize = 50000, minInsertSize = 5, insertLength=[])

parser_g.add_option('-l', dest='insertLength', type='int', action='append',
                    metavar='LENGTH',
                    help='(nt) Insert size to generate - you can specify multiple values')

parser_g.add_option('--maxinsert', dest='maxInsertSize', type='int', metavar='NT',
                    help='(nt) Maximum insert size to map')
parser_g.add_option('--mininsert', dest='minInsertSize', type='int', metavar='NT',
                    help='(nt) Minimum insert size to map')
parser_g.add_option('--readlength', dest='readLength', type='int', action='append',
                    metavar='NT', help='(nt) Size of the reads (default: 36). It ' +
                    'is possible to define multiple values which will correspond to '+
                    '-l')
parser_g.add_option('--sd', dest='insertSigma', action='append',
                    metavar='NT',
                    help='Insertlength is drawn from a normal distribution with this ' +
                    'value as sd. Defaults is 0.05 * insertlength. It is possible to ' +
                    'define multiple values, it is possible to define a value like ' +
                    'P0.01, defining 1 % of the insert length')

parser_g.add_option('-n', dest='noPairs', type='int', action='append',
                    help='No of readpairs to generate per -l. It is possible to define ' +
                    'multiple values')
parser_g.add_option('--recreateindex', dest='recreateindex', action='store_true',
                    help='Force recreating the bowtie index')

parser.set_defaults(simPSize=[], simPType=[])

def opColorList(option, opt_str, value, parser):
    colors = getattr(parser.values, option.dest)
    if not colors: colors = []
    newcolor = '#' + value
    colors.append(newcolor)
    setattr(parser.values, option.dest, colors)
    
parser_g.add_option('--simcolors', dest='simColors', metavar='COLOR',
                    nargs=1, action='callback', type="string",
                    help='Color to use for simulated points (RRGGBBAA)',
                    callback=opColorList)

parser_g.add_option('--simlinecolors', dest='simLineColors', metavar='STRING',
                    action='callback', type="string", nargs = 1, callback=opColorList,
                    help='Color to use for lines between simulated points (RRGGBBAA)')

parser_g.add_option('--simpointsize', dest='simPSize', metavar='INT',
                    action='append', help='point size for simulated data')
parser_g.add_option('--simpointtype', dest='simPType', metavar='INT',
                    action='append', help='point type for simulated data', type='int')

parser.set_defaults(deletes = [], inserts = [])
parser_g.add_option('-I', dest='inserts', action='append',
                  help='START:LEN - Simulate a (random) insert in the sequence ' +
                    '(for a random insert use -)')
parser_g.add_option('-D', dest='deletes', action='append',
                    help='START:STOP - Simulate a deletion in the sequence, '+
                    '(for a random delete use -)')

## Arguments: Find NNNs
parser_n = optparse.OptionGroup(parser, "Find & identify stretches of NNs")
parser_n.add_option('-N', dest='findNNN', action='store_true',
                  help='discover stretches of NNNs and annotate these')
parser.set_defaults(minNN=5, NColor="#000000")
parser_n.add_option('--minNN', dest='minNN', type='int', metavar='NT',
                  help='Minimum size of a stretch of NNs to be displayed (5)')
parser_n.add_option('--Ncolor', dest='NColor', metavar='COLOR',
                    help='Color of the blocks representing stretches of NNs (rygbp "'+
                    'or #ABCDEF, default: #CACCCF)')

## Arguments: Parse bowtie data
parser_r = optparse.OptionGroup(parser, "(Real) bowtie input data")
parser.set_defaults(bowtieInputs=[], bowtieLimit=-1)

bowtieInputsHelp = """ A directory with bowtie output data """

parser_r.add_option('-b', dest='bowtieInputs', action='append',
                    metavar='DIR', help=_hf(bowtieInputsHelp))
parser_r.add_option('--limitbowtie', dest='bowtieLimit', type='int',
                    metavar='NO',
                    help='limit the number of reads to per bowtie input file')
parser_r.add_option('--bowtiemaxinsert', dest='bowtiemaxinsert', type='int',
                    metavar='LEN', default=1e12,
                    help='Max insert length from a bowtie file to consider')

parser.set_defaults(bowtiePType=[] ,bowtiePSize=[])

parser_g.add_option('--bowcolors', dest='bowtieColors', metavar='COLOR', action='callback',
                    type="string", nargs=1, callback=opColorList, 
                    help='Color to use for simulated points (RRGGBBAA)')
parser_g.add_option('--bowlinecolors', dest='bowtieLineColors', metavar='STRING',
                    type="string", nargs=1, callback=opColorList, action='callback',
                    help='Color to use for lines between simulated points (RRGGBBAA)')

parser_r.add_option('--bowpointsize', dest='bowtiePSize', metavar='INT', 
                    action='append',
                    help='point size for bowtie data')
parser_r.add_option('--bowpointtype', dest='bowtiePType', metavar='INT', 
                    action='append',
                    help='point type for bowtie data')

parser.add_option_group(parser_i)
parser.add_option_group(parser_g)
parser.add_option_group(parser_n)
parser.add_option_group(parser_r)

(options, args) = parser.parse_args()

##############################################################################
## Set up logging
l = logging.getLogger('hagfish')
handler = logging.StreamHandler()
logmark = chr(27) + '[0;37;44mHAGFISH' + \
          chr(27) + '[0m ' 

formatter = logging.Formatter(
    logmark + '%(levelname)-6s %(message)s')

handler.setFormatter(formatter)
l.addHandler(handler)

if options.verbose >= 2:
    l.setLevel(logging.DEBUG)
elif options.verbose == 1:
    l.setLevel(logging.INFO)
else:
    l.setLevel(logging.WARNING)

#set default colors
if not options.simColors:
    options.simColors = ['#42EB17FF']
if not options.simLineColors:
    options.simLineColors = ['#EBCE17ff']
if not options.bowtieColors:
    options.bowtieColors = ['#006385FF']    
if not options.bowtieLineColors:
    options.bowtieLineColors = ['#FF6B9044']
if not options.simPSize:
    options.simPSize = [0.5,]
if not options.simPType:
    options.simPType=[21,]

if not options.bowtiePSize:
    options.bowtiePSize = [0.5,]
if not options.bowtiePType:
    options.bowtiePType=[21,]

options.plotMode = [x.lower() for x in options.plotMode]
if not options.plotMode:
    options.plotMode=['bs']
    
  
l.info("starting hagfish on %s" % time.ctime())
l.info("Executed with these arguments:")
l.info("  %s" % " ".join(sys.argv))
l.info('-' * 80)
if options.xstart:
    l.info(" Analysis starts at nucleotide %d" % options.xstart)
if options.xstop:
    l.info(" Analysis stops at nucleotide %d" % options.xstop)

startTime = time.time()
    
def seqReader(sequence):
    F = open(sequence)
    title = F.readline().strip()[1:]    
    seq = ''.join([x.strip().lower()
                   for x
                   in F.readlines() if x[0] != '>'
                   ] )
    F.close()
    return title, seq

########################################$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# Model definitions

#
def discoverBorders(fit):
    l.debug("debugging discover borders")
    
    x = list(fit[0])
    y = list(fit[1])

    maxy = max(y)
    maxLoc = y.index(maxy)
    maxx = x[maxLoc]
    realPeak = maxx

    #find peak edge going down
    i = maxLoc - 1
    leftEdge = realPeak
    rightEdge = realPeak
    while i >= 1:
        this, prev = y[i], y[i-1]
        slope = (prev-this) / x[i-1] - x[i]
        if (prev > this) or  (this < 0.1 * maxy):
            leftEdge = x[i]
            break
        i -= 1
    else: leftEdge = x[i]
    
    i = maxLoc + 1
    while i <= len(x) -1:
        this, next = y[i], y[i+1]
        slope = (this - next) / (x[i] - x[i+1])
        if (next > this) or (this < 0.1 * maxy):
            rightEdge = x[i]
            break
        i += 1
    else: rightEdge = x[i]

    l.info('Discovered peak borders at: %s %s %s' % (leftEdge, realPeak, rightEdge))
    return leftEdge, realPeak, rightEdge
        
    
    
def modelDataset(d):    

    iss = d['e2'] - d['s1']

    d['ymedian'] = np.median(iss)

    d['yhist'], edges = np.histogram(iss, bins=400, range=(0,30000), new=True)
    d['ymids'] = np.array([(0.5 * (edges[i]+edges[i+1])) for i in range(len(edges)-1)])

    #use R for smoothing
    fit = r['loess.smooth'](
        d['ymids'], d['yhist'], ann=False, family="gaussian",
        evaluation=100, span=0.03)
    
    d['yfitx'] = list(fit[0])
    d['yfity'] = list(fit[1])
    
    #find max in the fit -
    left, top, right = discoverBorders(fit)
    d['peakLow'] = left
    d['peakHigh'] = right
    d['ypeak'] = top
    d['insertSizeObserved'] = top

    y = iss - top
    d['y'] = y
    
    l.info("Modelling set %(name)s" % d)
    l.info(" - y: %s .. %s" % ("/".join(map(str, y[:5])),"/".join(map(str, y[-5:]))))
    l.info(" - observed insert size %(insertSizeObserved)d" % d)

def model_pair_midpoint(s1,s2,e1,e2):
    return s1 + (0.5 * (e2-s1)), (e1-s2)

def model_pair_start(s1,s2,e1,e2):
    return s1, (e1-s2)
    
CURRENTPAIRMODEL = model_pair_midpoint
def model_set_correct(x, y):
    z = copy.copy(y)
    z.sort()
    insertSizeObserved = z[int(0.5 * len(z))]
    q = y - insertSizeObserved
    l.debug("observed insert size %f" % insertSizeObserved)
    return x, q, insertSizeObserved
    
def model_set_dummy(x, y):
    z = copy.copy(y)
    z.sort()
    return x,y,z[int(0.5 * len(z))]

CURRENTSETMODEL = model_set_correct

def get_subset(start, end, array, more_arrays):
    """
    Returns a subset of the array(s) based on the start & end.
    """

    condition = np.logical_and(
        (np.greater_equal(array, start) == True),
        (np.less_equal(array, stop) == True))

    rv = np.extract(array, condition)
    for a in more_arrays:
        rv.append(np.extract(a, condition))
    return rv


########################################$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# Bowtie handling routines

def bowtieSearch(index, seq1, seq2, minInsertSize, maxInsertSize):
    bowtieArgs = ["bowtie",
                  "-S", 
                  "-r", "--ff",
                  "-I", str(minInsertSize),
                  "-X", str(maxInsertSize),
                  "--all", "--best", index,
                  "-1", seq1,
                  "-2", seq2 ]
    l.debug("about to execute %s" % " ".join(bowtieArgs))
    results = sp.Popen(bowtieArgs, stdout=sp.PIPE, stderr=sp.PIPE)\
              .communicate()[0]\
              .strip()\
              .split("\n")

    results = [x for x in results if x[0] != '@']
    while len(results) >= 2:
        line1 = results.pop(0).strip()
        line2 = results.pop(0).strip()
        if not line1 and line2:
            l.error('Invalid bowtie results')
            l.error(line1)
            l.error(line2)

        l1 = int(line1.split("\t")[3])
        l2 = int(line2.split("\t")[3])
        
        yield l1, l2

def buildBowtieIndex(seqFile):
    #see if there is already an tmp index for this sequence
    newIndex = []
    if os.path.exists('hagfish_indici'):
        with open('hagfish_indici', 'r') as indexindex:
            for line in indexindex.readlines():                
                indexseqfile, bowtieindex = line.split()                
                if seqFile == indexseqfile:
                    if not options.recreateindex:
                        #found the index, not recreating it, so return it
                        #for reuse
                        l.info("Using (old) bowtieindex at %s" % bowtieindex)
                        return bowtieindex
                else:
                    newIndex.append((indexseqfile, bowtieindex))
                
    tmpdir = tempfile.mkdtemp(prefix='bowtie_tmpindex_')
    l.info("Building bowtie index in %s" % tmpdir)
    tmpbase = os.path.join(tmpdir, 'bowtie_index')
    p = sp.Popen(["bowtie-build", seqFile, tmpbase], stdout=sp.PIPE, stderr=sp.PIPE).communicate()[0]
    l.debug("output %s ... %s" % (p[:20], p[-20:]))
    l.info("bowtie index created in %s" % tmpbase)
    newIndex.append((seqFile, tmpbase))
    l.info("Writing new bowtie index-index")    
    with open('hagfish_indici', 'w') as indexindex:
        for a,b in newIndex:
            indexindex.write("%s\t%s\n" % (a,b))

    
    return tmpbase

def parseBowtieFile(seqName, f, limit, maxinsert):
    l.info('Parsing bowtie output "%s", max %d records and a max insert size of %d' % (
        seqName, limit, maxinsert))
    l.debug('  from "%s"' % f)

    ss1 = []
    ee1 = []
    ss2 = []
    ee2 = []
    
    #use samtools to open the file
    F = sp.Popen("samtools view -f 2 %s" % f, shell=True, stdout=sp.PIPE).stdout
    #F = open(f)
    i = 0
    while True:
        line1 = F.readline()
        
        if not line1: break
        if line1[0] == '@': continue
        
        line2 = F.readline()
        l1 = line1.strip().split()
        l2 = line2.strip().split()

        try:
            if l1[2] == '*': continue
            if l2[2] == '*': continue
        except IndexError:
            print line1
            print line2
            raise

        if l1[2] != seqName: continue
                
        i += 1
        if limit > -1 and i > limit: break

        s1 = int(l1[3])
        s2 = int(l2[3])
        rl = len(l1[9])

        #only consider inserts smaller than a predefined value 
        if ((s2+rl) - s1) > maxinsert: continue
        

        ss1.append(s1)
        ss2.append(s2)
        ee1.append(s1+rl)
        ee2.append(s2+rl)
        if i < 2:
            l.debug("Bowtie hit found %d %d %d %d" % (
                s1, s1+rl, s2, s2+rl))
            l.debug("  - %s " % realSeq[s1:s1+rl])
            l.debug("  - %s " % realSeq[s2:s2+rl])
        
    F.close()
    l.debug('yielding %d readpairs' % len(ss1))
    return np.array(ss1), np.array(ee1), np.array(ss2), np.array(ee2)

def testBowtieFile(f):
    """
    Test if this appears to be a valid bowtie-pair file
    """
    return True

def getRealBowtieData(seqName, indirs, readsPerFile, maxInsert):
    i = 0
    for indir in indirs:
        if not os.path.isdir(indir):
            l.error('Not a directory: %s' % indir)
            sys.exit()
        i += 1

        for infile in os.listdir(indir):
            if not infile[-4:] == '.bam': continue
            if infile[0] == '.': continue
            
            inpath = os.path.join(indir, infile)
            if os.path.isdir(inpath):
                continue
            if testBowtieFile(inpath):
                l.info("considering the following file: %s" % inpath)
                ss1, ee1, ss2, ee2  = parseBowtieFile(seqName, inpath, readsPerFile, maxInsert)

                d = { 's1' : np.array(ss1),
                      'e1' : np.array(ee1),
                      's2' : np.array(ss2),
                      'e2' : np.array(ee2),
                      'dir' : indir,
                      'name' : 'Bowtie %s' % inpath}
                modelDataset(d)
                yield(d)


#########################################################################################
# generate random pairs

def randomPairGenerator(bowtieIndex, realSeq, noPairs, readLength,
                        insertLen, insertSigma, minInsertSize, maxInsertSize,
                        xstart, xstop):

    
    realSeqlen = len(realSeq)

    if not xstart:
        xstart = 0
    if not xstop:
        xstop = realSeqLen

    xstart = max(0, xstart - (readLength * 2))
    #xstop = xstop - (iLen + (2*readLength))
    
    ss1 = []
    ss2 = []
    ee1 = []
    ee2 = []
    
    noTooLargeInserts = 0
    noTooSmallInserts = 0

    fragfile1 = tempfile.NamedTemporaryFile(delete=False)
    fragfile2 = tempfile.NamedTemporaryFile(delete=False)
    
    fragfile1Name = fragfile1.name
    fragfile2Name = fragfile2.name
    
    for i in range(noPairs):
        iLen = max(0, int(random.gauss(insertLen, insertSigma)))
        start = random.randint(xstart, xstop)

        s1 = start
        s2 = s1 + readLength
        e1 = s2 + iLen
        e2 = e1 + readLength

        seq1 = realSeq[s1:s2]
        seq2 = realSeq[e1:e2]
        if 'n' in seq1: continue
        if 'n' in seq2: continue
        

        fragfile1.write("%s\n" % (seq1))
        fragfile2.write("%s\n" % (seq2))

    fragfile1.close()
    fragfile2.close()
    l.debug("written artifical reads to %s and %s" % (fragfile1Name, fragfile2Name))
    ii = 0
    for p1, p2 in bowtieSearch(bowtieIndex, fragfile1Name, fragfile2Name,  minInsertSize, maxInsertSize):
        ss1.append(p1)
        ee1.append(p1+readLength)
        ss2.append(p2)
        ee2.append(p2+readLength)
        ii += 1
        if ii < 3:
            l.debug("Simulate hit found %d %d %d %d" % (
                p1, p1+readLength, p2, p2+readLength))
            l.debug("  - %s " % realSeq[p1:p1+readLength])
            l.debug("  - %s " % realSeq[p2:p2+readLength])

    l.info("Observed %d readpairs mapped to the sequence" % len(ss1))
    return np.array(ss1), np.array(ee1), np.array(ss2), np.array(ee2)



################################################################################
## Plot functions

def plotNNN():
    NColor = options.NColor   
    if NColor in list('rygbp'):
        NColor = colors[NColor]

    NNNPlotArgs = {
        'border' : 'NA',
        'col' : NColor,
        'lwd' : 1,    
        }
    legends.append("Ns")
    legendcol.append(NNNPlotArgs['col'])
    dx = abs( (graphMaxY - graphMinY) / 30.0)
    for N in NNs:        
        r.polygon([N[0], N[1], N[1], N[0]],
                  [graphMinY - dx, graphMinY - dx, graphMinY, graphMinY],
                  **NNNPlotArgs)

def plotGrid():
    for y in range(xstart, xstop, int((xstop - xstart) / options.gridLines)):
        r.abline(-y,0.5, col='#' + options.gridColor)
        r.abline(y,-0.5, col='#' + options.gridColor)
         
def drawAnySet(d, col, lcol, cex, pch):

    s1 = d['s1']
    e1 = d['e1']
    s2 = d['s2']
    e2 = d['e2']
    ys = d['y']

    #ize = d['observedInsertSize']
    #.info("DrawAnySet points: %d insize: %d" % (
    #   len(xs), insize))
    #.info("DrawAnySet points size %s type %s col %s linecol %s" %
    #      (cex, pch, col, lcol))
    #.info("DrawAnySet xxs %s" % xs[:5])
    #.info("DrawAnySet yys %s" % ys[:5])
    
    #halfsize = 0.5 * insize
    
    if options.drawLines:
       l.info("Start drawing lines")
       for i in range(len(s1)):
           r.lines([s1[i], e2[i]], [ys[i],ys[i]], col=lcol, type='l')

    r.points(s1, ys, col=col, cex=cex, pch=pch, **plargs)
    r.points(e2, ys, col=col, cex=cex, pch=pch, **plargs)
    #r.points(xs, ys, col=col, cex=cex, pch=pch, **plargs)
            
    #r.points(xs, ys, col=d['col'], cex=d['cex'], pch=d['pch'], **plargs)


################################################################################
# Draw the 'REAL' bowtie data

def wg(i, l):
    return l[i % len(l)]

def plotRibbons():
    i = 0

    #flatten sets
    r_ok = np.zeros(realSeqLen, dtype=np.int)
    r_high = np.zeros(realSeqLen, dtype=np.int)
    r_low = np.zeros(realSeqLen, dtype=np.int)

    for d in allBowData:
        l.info("Ribbonifying bowtie dataset %s" % d['name'])
        
        l.debug("top, botton %s %s" % (d['peakLow'], d['peakHigh']))
        #filter out those pairs that are below / on / above the peak

        peakLow = d['peakLow']
        peakHigh = d['peakHigh']
        
        def ff(a,b):
            dist = b-a
            if dist < peakLow:
                r_low[a:b] += 1
            elif dist > peakHigh:
                r_high[a:b] += 1
            else:
                r_ok[a:b] += 1

        FF = np.vectorize(ff)
        FF(d['s1'], d['e2'])
        l.info("Done interpretind %s" % d['name'])

        
    #prepare for plotting
    def binnify(noBins, start, stop, r):
        binSize = int((stop-start) / noBins)
        bins = range(xstart, xstop, binSize)
        noBins = len(bins)-1
        out_r = np.zeros(noBins)
        for x in range(noBins):
            out_r[x] = np.average(r[bins[x]:bins[x+1]])
        return bins[:-1], out_r

    r_ok_bins, r_ok_binned = binnify(800, xstart, xstop, r_ok)
    r_high_bins, r_high_binned = binnify(800, xstart, xstop, r_high)
    r_low_bins, r_low_binned = binnify(800, xstart, xstop, r_low)
        
    r.plot(r_high_bins, r_high_binned,
           col='darkred', ann=False, type='h',  xaxt="n", yaxt="n",  xlab="", ylab="", lwd=2)
#           ylim = robjects.IntVector([0, 50]))
    #r.plot(r_ok_bins, r_ok_binned,
    #       col='green', ann=False, type='h',  xaxt="n", yaxt="n",  xlab="", ylab="", lwd=2,
    #       ylim = robjects.IntVector([0, 50]))
    r.plot(r_ok_bins, r_ok_binned,
           col='darkgreen', ann=False, type='h',  xaxt="n", yaxt="n",  xlab="", ylab="", lwd=2)
    r.plot(r_low_bins, r_low_binned,
           col='darkblue', ann=False, type='h',  yaxt="n", lwd=2, ylab="")
    #, ylim = robjects.IntVector([0, 50]))
        
def drawBowData():
    i = 0
    for d in allBowData:
        col = wg(i, options.bowtieColors)
        lcol = wg(i, options.bowtieLineColors)
        cex = wg(i, options.bowtiePSize)
        pch = wg(i, options.bowtiePType)
        drawAnySet(d, col, lcol, cex, pch)
        legends.append("Bowtie %s (%s)" % (d['name'], d['insertSizeObserved']))
        legendcol.append(col)
        legendcol.append(lcol)
        legendtyp.append(pch)
        legendsiz.append(cex)
        i += 1
                 

################################################################################
# Draw the simulated datasets
def drawSimData():
    i = 0
    for d in simulDataSets:
        col = wg(i, options.simColors)
        lcol = wg(i, options.simLineColors)
        cex = wg(i, options.simPSize)
        pch = wg(i, options.simPType)
        drawAnySet(d, col, lcol, cex, pch)
        legends.append("Sim")# % d['insertSize'])
        legendcol.append(col)
        legendcol.append(lcol)
        legendtyp.append(pch)
        legendsiz.append(cex)
        i += 1

def drawLegend():
    if len(legends) == 0:
        return
    l.info("Drawing legend")
    l.debug("legend keys: %s" % legends)
    l.debug("legend colors: %s" % legendcol)
    r.legend(x="topright", legend = legends,
             pch=robjects.FloatVector(legendtyp),
             cex=1,
             lwd=5,
             col=robjects.StrVector(legendcol),
             **{
                 'pt.bg' : robjects.StrVector(legendcol)
                } )


################################################################################
## Start program

# Initalize
simulDataSets = []
NNs = []
allBowData = []

basefilename = options.basename

#see if there is a data input
allDataFields = '''inputSeqFile seqName seq seqLen
                   realSeq realSeqLen simulDataSets
                   NNs allBowData'''.split()

if options.dataIn:
    l.info("Reading data file from %s.state.gz" % basefilename)
    DI = gzip.open(basefilename + '.state.gz', 'rb')
    allData = cPickle.load(DI)
    DI.close()
    for a in allDataFields:
        globals()[a] = allData[a]

## read the sequence
if options.sequence:
    inputSeqFile = options.sequence
    seqName, seq = seqReader(inputSeqFile)
    seqLen = len(seq)
    realSeq = seq
    realSeqLen = len(seq)
 
#it is possible that basefilename is not defined yet - get it
#from the sequence input
if not basefilename:
    basefilename = os.path.basename(inputSeqFile)
    if '.' in basefilename:
        basefilename = basefilename.rsplit('.')[0]

l.debug("Imported sequence %s" % (inputSeqFile))
l.debug("Sequence Id %s" % (seqName))
l.debug("Sequence length %d" % (seqLen))

bowtieIndex = buildBowtieIndex(inputSeqFile)

##############################################################################
## Simulate an "original" sequence - to introduce inserts / deletes into the
## simulated readpairs

## So what happens is that we generate a sequence with inserts/deletes
## based on the input sequence. If we then generate simulated bowtie
## data on the new, generated sequence, it will appear as if the
## assembly is wrong.

#inserts
if options.inserts or options.deletes:
    realSeq = list(seq)
    for insert in options.inserts:
        if insert == '-':
            _f = random.randint(0, seqLen)
            _t = random.randint(_f, seqLen)
        else:
            _f, _t = map(int, insert.split(':'))

        l.info("processing insert %s (%d %d)" % (
            insert, _f, _t))

        for x in range(_f, _t):
            realSeq[x] = 'D'

    deletions = []
    l.debug("deletions %s" % options.deletes)
    for deletion in options.deletes:
        l.debug("preparing deletion %s" % deletion)
        if deletion == '-':
            _f = random.randint(0, seqLen)
            _t = random.randint(_f, seqLen)
            deletions.append((_f, _t))
        else:
            a,b = deletion.split(':')
            deletions.append((int(a), int(b)))

    deletions.sort()
    for dF, dT in deletions:
        dSeq = "".join([random.choice(['a', 'c', 'g', 't']) for x in range(dT - dF)])
        l.debug("creating an deletion from %d to %d" % (dT, dF))
        realSeq[dF] = realSeq[dF] + dSeq 

    #collapse the 'real' sequence
    realSeq = "".join([x for x in realSeq if not x == 'D'])
    realSeqLen = len(realSeq)
    l.debug("simul. 'real' seq length %d : %s..%s" % (realSeqLen, realSeq[:10], realSeq[-10:]))

##############################################################################
## Simulate readpairs

for i in range(len(options.insertLength)):
    insertLength = options.insertLength[i]    
    if options.readLength:
        readLength = options.readLength[i % len(options.readLength)]
    else:
        readLength = 36

    if options.noPairs:
        noPairs = options.noPairs[i % len(options.noPairs)]
    else:
        noPairs = 1000

    if options.insertSigma:
        insertSigma = options.insertSigma[i % len(options.insertSigma)]
        if insertSigma[0].lower() == 'p':
            insertSigma = float(insertSigma[1:]) * insertLength
        else:
            insertSigma = float(insertSigma)
    else:
        insertSigma = 0.05 * insertLength

    _colorList = list(options.simColors)
    _lineColorList = list(options.simLineColors)

    l.debug("start simulating %d readpairs with insertlength %d" % (
        noPairs, insertLength))

    s1, e1, s2, e2 = \
        randomPairGenerator(bowtieIndex, realSeq, noPairs, readLength, insertLength,
                             insertSigma, options.minInsertSize, options.maxInsertSize,
                             options.xstart, options.xstop)
    #xs, ys = get_subset(options.
    l.info("Simulated %d readpairs" % len(s1))


    ds = {'s1' : s1,
          'e1' : e1,
          's2' : s2,
          'e2' : e2,
          'name' : 'Sim %d' % insertLength,
          'insertLength' : insertLength,
          'readLength' : readLength}
    modelDataset(ds)
    simulDataSets.append(ds)
    
##############################################################################
## Identify stretches of NNs
##
if options.findNNN:
    NFinder = re.compile("N{%d,}" % options.minNN, re.I)
    for match in NFinder.finditer(seq):
        NNs.append([match.start(), match.end()])
    l.info("Identified %s stretches of NNs" % len(NNs))
    l.debug(" first 5 N stretches: %s" % NNs[:5])
    
##############################################################################
## Start drawing the graph

#preread bowtie data (not this is quite a lot, not very elegant to preread :()
l.info("Start reading ALL bowtie data")

for d in getRealBowtieData(seqName, options.bowtieInputs,
                           options.bowtieLimit,
                           options.bowtiemaxinsert):
    allBowData.append(d)
    l.info("read %s (%d datapoints)" % (d['dir'], len(d['s1'])))

l.info("Finished - readStart reading ALL bowtie data")

graphMaxY = 100
graphMinY = -100

    
for d in simulDataSets:
    graphMaxY = max(graphMaxY, max(d['y']))
    graphMinY = min(graphMinY, min(d['y']))

for d in allBowData:
    l.debug("Bowtie graphMax %d %d" % (graphMaxY, np.amax(d['y'])))
    graphMaxY = max(graphMaxY, max(d['y']))
    l.debug("Bowtie  graphMin %d %d" % (graphMinY, np.amin(d['y'])))
    graphMinY = min(graphMinY, min(d['y']))

graphMaxY = 1.2 * graphMaxY
if graphMinY < 0:
    graphMinY = 1.2 * graphMinY
else:
    graphMinY = 0.5 * graphMinY

l.info("Determined graph y boundaries: %d %d" % (graphMinY, graphMaxY))

xstart = options.xstart
if options.xstop: xstop = options.xstop
else: xstop = seqLen

#determine the x size
if options.xsize[-1] == 'P':
    xsize = seqLen / int(options.xsize[:-1])
else:
    xsize = int(options.xsize)

l.info("preparing graph with size (x/y) %d/%d" % (
    xsize, options.ysize))


PNGARGS = {
    'bg' : '#ffffff',
    'col' : '#000000',
    }

graphYRange = graphMaxY - graphMinY
l.info("Graph limits xmin %s xmax %s ymin %s ymax %s" % (
    xstart, xstop, graphMinY, graphMaxY))
PLOTARGS = {
    'ylim' : robjects.IntVector([(graphMinY - (graphYRange / 20)), graphMaxY]),
    'xlim' : robjects.IntVector([xstart, xstop]),
    'xlab' : 'position (nt)',
    'ylab' : 'corrected distance (nt)',
    'bg'   : '#ff00ff',
    'col.lab' : '#003366',
    'col.main' : '#003366',
    'col.sub' : '#003366',
    'col.axis' : '#006633',
    }

PLOT1ARGS = copy.copy(PLOTARGS)
PLOT2ARGS = copy.copy(PLOTARGS)
PLOT1ARGS['xaxt'] = "n"
PLOT1ARGS['xlab'] = ""

plargs = { 'xlab': 'insert size',
           'xlab': 'position',
           'type' : 'p'}

plargsLine = { 'pch' : 19,
               'cex': 1,
               'type' : 'l'}

        
legends = []
legendcol = []
legendtyp = []
legendsiz = []

#################################################################################
# Draw the blocks showing NNNs

if 'bs' in options.plotMode:
    r.png(basefilename +'.bs.png', width=xsize, height=options.ysize, pointsize=12, **PNGARGS)
    r.par(oma=robjects.array.array('f', [3,3,0.5,0.5]))
    r.par(mar=robjects.array.array('f', [0,0,0,0]))
    r.par(mgp=robjects.array.array('f', [0.5,0.5,0.001]))
    r.layout(r.matrix([1,2,3,4,5], ncol=1),
             heights=robjects.IntVector([10,1,1,1,1]))
    THISPLOTARGS = copy.copy(PLOTARGS)
    THISPLOTARGS['xaxt'] = 'n'
    THISPLOTARGS['xlab'] = ''
    r.plot([], [],    **THISPLOTARGS    )
    l.info("drawing a BS graph")
    if options.grid: plotGrid()
    if options.findNNN: plotNNN()
    drawBowData()
    drawSimData()
    drawLegend()
    plotRibbons()
    r['dev.off']() #close graph
    
if 'sb' in options.plotMode:
    r.png(basefilename +'.sb.png', width=xsize, height=options.ysize, pointsize=12, **PNGARGS)
    #generate an empty graph
    r.plot([], [], **PLOTARGS    )

    l.info("drawing a SB graph")
    if options.grid: plotGrid()
    if options.findNNN: plotNNN()
    drawSimData()
    drawBowData()
    drawLegend()
    r['dev.off']() #close graph
    
if 'split' in  options.plotMode:
    r.png(basefilename +'.split.png', width=xsize, height=options.ysize, pointsize=12, **PNGARGS)
    #generate an empty graph
    r.plot([], [], **PLOTARGS    )

    r.par(oma=robjects.array.array('f', [3,3,0.5,0.5]))
    r.par(mar=robjects.array.array('f', [0,0,0,0]))
    r.par(mgp=robjects.array.array('f', [0.5,0.5,0.001]))
    #          c(3,3,3,3)+.1, mar=c(0,0,0,0)+0.1, mfrow=c(3,3))
    l.info("drawing a split mode graph")
    r.par(mfrow=robjects.array.array('i', [2,1]))
    r.plot([], [], **PLOT1ARGS    )
    if options.grid: plotGrid()
    drawSimData()
    drawLegend()
    legends = []; legendcol = [];
    r.plot([], [], **PLOT2ARGS    )
    if options.grid: plotGrid()
    drawBowData()
    drawLegend()
    r['dev.off']() #close graph


if 'ribbon' in options.plotMode:
    r.png(basefilename +'.ribbon.png', width=xsize, height=options.ysize, pointsize=12, **PNGARGS)
    #generate an empty graph
    r.plot([], [], **PLOTARGS    )

    for d in allBowData:
        l.info("top, botton %s %s" % (d['peakLow'], d['peakHigh']))
        #filter out those pairs that are below / on / above the peak

        l.info("flatting sets")

        #flatten sets
        r_ok = np.zeros(realSeqLen, dtype=np.int)
        r_high = np.zeros(realSeqLen, dtype=np.int)
        r_low = np.zeros(realSeqLen, dtype=np.int)

        peakLow = d['peakLow']
        peakHigh = d['peakHigh']
        
        def ff(a,b):
            dist = b-a
            if dist < peakLow:
                r_low[a:b] += 1
            elif dist > peakHigh:
                r_high[a:b] += 1
            else:
                r_ok[a:b] += 1

        FF = np.vectorize(ff)
        FF(d['s1'], d['e2'])
        l.info("Done flattening ")

        def etm(e):
            return np.array([(0.5 * (e[i]+e[i+1])) for i in range(len(e)-1)])
        
        #prepare for plotting
        def binnify(noBins, start, stop, r):
            binSize = int((stop-start) / noBins)
            bins = range(xstart, xstop, binSize)
            noBins = len(bins)-1
            out_r = np.zeros(noBins)
            for x in range(noBins):
                out_r[x] = np.average(r[bins[x]:bins[x+1]])
            return bins[:-1], out_r

        r_ok_bins, r_ok_binned = binnify(500, xstart, xstop, r_ok)
        r_high_bins, r_high_binned = binnify(500, xstart, xstop, r_high)
        r_low_bins, r_low_binned = binnify(500, xstart, xstop, r_low)
        
        r.plot(r_ok_bins, r_ok_binned,
               col='green', ann=False, type='s')
        r.points(r_high_bins, r_high_binned,
               col='red', ann=False, type='s')
        r.points(r_low_bins, r_low_binned,
               col='blue', ann=False, type='s')
#        r.points(r_ok[1900000:2000000], col='green', ann=False)
#        r.points(r_low[1900000:2000000], col='blue', ann=False)
        
#        cutoff = 10
#        r_ok_flat = np.greater(r_ok, cutoff)
#        r_high_flat = np.greater(r_high, cutoff)
#        r_low_flat = np.greater(r_low, cutoff)
#        r.plot(r_ok_flat + 1)
#        r.points(r_high_flat+2)
#        r.points(r_low_flat)

        #r.heatmap(r_ok[0])
        
                
        
    r['dev.off']() #close graph
    
if 'yd' in options.plotMode:
    r.require('graphics')
    #print y histogram
    i = -1; j = 1
    lowf = 0.0001
    graphOpen = False
    for d in allBowData:
        l.info("creating insert size distribution graph for")
        l.info("   %s" % d['name'])
        i += 1
        if i % 4 == 0:
            if graphOpen:
                r['dev.off']() #close graph
            r.png(basefilename +('.ydist.%d.png' % j), width=1000, height=700,
                  pointsize=12, **PNGARGS)
            j += 1
            r.par(oma=robjects.array.array('f', [3,3,0.5,0.5]))
            r.par(mar=robjects.array.array('f', [0,0,0,0]))
            r.par(mgp=robjects.array.array('f', [0.5,0.5,0.001]))
            r.layout(r.matrix([1,2,3,4], ncol=1))
            graphOpen = True
        
        #generate an empty graph
        TPA = copy.copy(PLOTARGS)
        if i == 1:
            TPA['ylab'] = 'frequency'
        if i == 3:
            TPA['xlab'] = 'Insert size (nt)'
        yvals = d['e2'] - d['s1']        
        r.plot(d['ymids'], d['yhist'], type='h', ann=False, lwd=2, col='grey')
        r.text(max(d['ymids']) * 0.8, max(d['yhist']) * 0.8,
               "%s (%s)" %  (d['name'], int(d['ypeak'])),
               pos=2, adj=robjects.FloatVector([0.5, 1]), cex=1.5)
        r.lines(d['yfitx'], d['yfity'], lwd=2, col="red")
        r.abline(v=d['peakLow'], lwd=2, col="darkred" )
        r.abline(v=d['ypeak'], lwd=2, col="blue" )
        r.abline(v=d['peakHigh'], lwd=2, col="darkgreen" )
        
    if graphOpen:
        r['dev.off']() #close graph
    
if 'none' in options.plotMode:
    pass


def writeRawOut(handle, dataset, what):
    for i in range(len(dataset['y'])):
        DO.write("%s\t%s\t%s\t%s\t%s\n" % (
            what,
            dataset['s1'][i],
            dataset['e1'][i],
            dataset['s2'][i],
            dataset['e2'][i]))

if options.dataOut:
    #write a tab delimted datafile
    DO = gzip.open(basefilename + '.tsv.gz', 'wb')
    for d in allBowData:
        writeRawOut(DO, d, 'bowtie')
    for d in simulDataSets:
        writeRawOut(DO, d, 'simul')
    DO.close()
    
    #dump program state
    DT = gzip.open("%s.state.gz" % basefilename, 'wb')
    allData = {}
    for a in allDataFields:
        allData[a] = globals()[a]
            
    cPickle.dump(allData, DT)
    DT.close()

l.info("stopping hagfish on %s" % time.ctime())
l.info("Run duration: %.4f seconds" % (time.time() - startTime))
