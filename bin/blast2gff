#!/usr/bin/env python
"""
Convert blastn output to gff
"""
import os
import sys
import optparse
import logging

from Bio.Blast import NCBIStandalone
from Bio.Blast import NCBIXML

logging.basicConfig(level=logging.ERROR, 
                    format = "%(levelname)s - %(message)s")
l = logging #shortcut

################################################################################
parser = optparse.OptionParser()
parser.add_option('-d', '--direction', dest='direction',
    help = 'output "query" based, "subject" based or "both"')
parser.set_defaults(output_match = False)
parser.add_option('-m', '--output_match', dest='output_match',
    help = 'output a match line?')
parser.add_option('-s', '--source', dest='source',
    help = 'gff source to use, is also incorporated in the feature names/ids')
parser.add_option('--debug', dest='debug',
    help = 'debugging string - no real fixed use here :)')

(options, args) = parser.parse_args()



################################################################################
#blast_parser = NCBIStandalone.BlastParser()

def cleanup_name(name):
    """
    Clean a name from forbidden characters
    """
    return name.replace(';', ','
            ).replace('=', '_'
            ).replace('%', '_'
            ).replace(',', '_')
            
def handle_blast_record(rec):    
    
    query_id = cleanup_name(
            rec.query.split()[0].replace(">", "").replace("lcl|", ""))
    full_query_name = cleanup_name(
        rec.query.replace(">", "").replace("lcl|", "")
            
        ) 
    
    l.debug("query: %s" % query_id)
    
    count = 0    
    for a in rec.alignments:
        count +=1
        subject_id = cleanup_name(
            a.title.replace(">", "").split()[0].replace("lcl|", ""))             
        full_subject_name =cleanup_name(a.title.replace(">", "").replace("lcl|", "")) 
    
        l.debug("hit against: %s" % subject_id)
        
        m_ss = a.hsps[0].sbjct_start
        m_se = a.hsps[0].sbjct_end
        m_qs = a.hsps[0].query_start
        m_qe = a.hsps[0].query_end
        
        m_eval = a.hsps[0].expect
        m_score = a.hsps[0].score
        
        if a.hsps[0].strand[0] == a.hsps[0].strand[1]:
            m_strand = "+"
        else:
            m_strand = "-"
            
        gff_queries = []
        gff_subjects = []
        
        basenameQ = "%s_%s_%s_%s" % (options.source, query_id, subject_id, count)
        basenameS = "%s_%s_%s_%s" % (options.source, subject_id, query_id, count)
        
        l.debug("basename Q is %s" % basenameQ)
        l.debug("basename S is %s" % basenameS)
        
        hcount = 0
        for h in a.hsps:
            hcount += 1
            ss,se = h.sbjct_start, h.sbjct_end 
            if se < ss: ss,se = se,ss
            
            qs,qe = h.query_start, h.query_end 
            if qe < qs: qs, qe = qe, qs
            
            if h.strand[0] == h.strand[1]: strand = '+'
            else: strand = '-'
                
            # idQ = "%s_h%s" % (basenameQ, hcount)
            # idS = "%s_h%s" % (basenameS, hcount)
            # 
            attribQ = ["ID=%s" % basenameQ,
                       "Name=%s" % basenameQ,
                       "Target=Sequence:%s %s %s" % (subject_id, ss, se),
                       "Hsp_expect=%s" % h.expect,
                       "Hsp_identities=%s" % str(h.identities),
                       "Hsp_bits=%s" % h.bits,                   
                        ]
    
            
            attribS = ["ID=%s" % basenameS,
                       "Name=%s" % basenameS,
                       "Target=Sequence:%s %s %s" % (query_id, qs, qe),
                        "Hsp_expect=%s" % h.expect,
                        "Hsp_identities=%s" % h.identities,
                       # "Hsp_frame=%s:%s" % h.frame,
                       # "Hsp_strand=%s:%s" % h.strand,
                        "Hsp_bits=%s" % h.bits,
                       # "Hsp_gaps=%s" % str(h.gaps),
                       ]
                       
            # if h.positives:
               # attribQ.append("Hsp_positives=%s" % str(h.positives))
               # attribS.append("Hsp_positives=%s" % str(h.positives))
                           
                       
            gff_queries.append(                
                [query_id, options.source, 'match', qs, qe, 
                h.score, strand, '.', ";".join(attribQ)])
            gff_subjects.append(                
                [subject_id, options.source, 'match', ss, se, 
                h.score, strand, '.', ";".join(attribS)])
            
            # #gahter statistics for the match
            # if ss < m_ss: m_ss = ss
            # if se > m_se: m_se = se
            # if qs < m_qs: m_qs = qs
            # if qe > m_qe: m_qe = qe
            # if h.expect < m_eval: m_eval = h.expect
            # if h.score > m_score: m_score = h.score
            # if strand != m_strand: m_strand = '.'
            # 
        # attribQ = ["ID=%s" % basenameQ,
                   # "Expect=%s" % m_eval,
                   # "Target=Sequence:%s %s %s" % (subject_id, m_ss, m_se),				   
                   # "Note=%s" % full_subject_name,
                   # "Blast_program=%s" % rec.application,
                   # "Blast_version=%s" % rec.version,
                   # "Blast_database=%s" % cleanup_name(rec.database),
                   # "Blast_seq_in_db=%s" % rec.num_sequences_in_database,
                   # "Blast_letters_in_db=%s" % rec.num_letters_in_database,
                   # "Blast_expect_cutoff=%s" % rec.expect,
                   # "Blast_filter=%s" % rec.filter,
                   # ]
                   # 
        # attribS = ["ID=%s" % basenameS, 
                   # "Expect=%s" % h.expect,
  				   # "Target=Sequence%s %s %s" % (query_id, qs, qe),
                   # "Note=%s" % full_query_name,
                   # "Blast_program=%s" % rec.application,
                   # "Blast_version=%s" % rec.version,
                   # "Blast_database=%s" % cleanup_name(rec.database),
                   # "Blast_seq_in_db=%s" % rec.num_sequences_in_database,
                   # "Blast_letters_in_db=%s" % rec.num_letters_in_database,
                   # "Blast_expect_cutoff=%s" % rec.expect,
                   # "Blast_filter=%s" % rec.filter,
                   # ]
# 
        # gff_query_match = [query_id, options.source, 'match',
                # m_qs, m_qe, m_score, m_strand, '.', ";".join(attribQ)]
        # gff_subject_match = [subject_id, options.source, 'match',
                # m_ss, m_se, m_score, m_strand, '.', ';'.join(attribS)]
    # 
        if options.direction == 'both' or options.direction == 'query':
            # if options.output_match:
                # print "\t".join([str(x) for x in gff_query_match])
            for gg in gff_queries:
                print "\t".join([str(x) for x in gg])
                
        if options.direction == 'both' or options.direction == 'subject':
            # if options.output_match:
                # print "\t".join([str(x) for x in gff_subject_match])
            for ss in gff_subjects:
                print "\t".join([str(x) for x in ss])


print "##gff-version 3"
try:
    for blast_record in NCBIXML.parse(sys.stdin):
        handle_blast_record(blast_record)
except Exception, e:
    print "*" * 80
    print "*" * 80
    print "* "
    print "* Failed : %s" % (e)
    print "* "
    print "*" * 80
    print "*" * 80
