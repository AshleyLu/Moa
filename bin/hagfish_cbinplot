#!/usr/bin/env python

import os
import sys
import math
import copy

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
import matplotlib as mpl
#import matplotlib.rc as rc
import pylab as pl

import logging
import optparse
import subprocess

## Arguments: General options 
parser = optparse.OptionParser()
parser.add_option('-v', dest='verbose', action="count", 
                  help='Show debug information')
parser.set_defaults(ntPerLine=1e6)
parser.add_option('-n', dest='ntPerLine',
                  help='no nucleotides per band')
parser.add_option('-i', dest='inputFile',
                  help='input file with the coverage data (npz, if not specified, '+
                  'the input file name will be inferred from the sequence Id')
parser.add_option('-l', dest='log', action='store_true',
                  help='take the log10 of the coverage')

parser.add_option('-A', dest='alayout', action='store_true',
                  help='Alternative layout')

parser.set_defaults(yfrac=0.95)

parser.add_option('-Y', dest='yfrac', type='float', help='percentage of the "ok" '
                  'fraction that must fall inside the Y boundaries of the graph - use '
                  'this to scale the y axis')
parser.add_option('-s', dest='start',
                  help='Start position (nt) of the plot')
parser.add_option('-e', dest='end',
                  help='End position (nt) of the plot')
parser.add_option('--ymax', dest='ymax',
                  help='Max value for the y axis')
parser.add_option('-o', dest='outfile',
                  help='Output file name')
parser.set_defaults(format=['png'])
parser.add_option('-f', dest='format', action='append',
                  help='Output format (may be defined more than once)')

options, args = parser.parse_args()

seqId = args[0]

l = logging.getLogger('hagfish')
handler = logging.StreamHandler()
logmark = chr(27) + '[0;37;44mHAGFISH' + \
          chr(27) + '[0m ' 

formatter = logging.Formatter(
    logmark + '%(levelname)-6s %(message)s')

handler.setFormatter(formatter)
l.addHandler(handler)

if options.verbose >= 2:
    l.setLevel(logging.DEBUG)
elif options.verbose == 1:
    l.setLevel(logging.INFO)
else:
    l.setLevel(logging.WARNING)

def quant(x, w):
    xs = np.sort(x)
    return xs[int(len(xs) * w)]
    


colHigh = mpl.colors.LinearSegmentedColormap.from_list(
    'colHigh', 
    ['green', 'yellow', 'red',], N=200)

colLow = mpl.colors.LinearSegmentedColormap.from_list(
    'colHigh', 
    ['green', 'cyan', 'blue', 'purple'], N=100)

if __name__ == '__main__':

    l.info("and I'm calling this sequence: %s" % seqId)
    if options.inputFile:
        inputFile = options.inputFile
    else:
        inputFile = os.path.join('combined', 
                                 '%s.combined.coverage.npz' % seqId)
    data = np.load(inputFile)
    r_ok = data['r_ok']
    r_high = data['r_high']
    r_low = data['r_low']
    r_low_binned = data['r_low_binned']
    r_high_binned = data['r_high_binned']

    bins_high = data['bins_high']
    bins_low = data['bins_low']

    seqLen = len(r_ok)

    if options.start:
        pStart = int(float(options.start))
    else:
        pStart = 0
    if options.end:
        pEnd = int(float(options.end))
        if pEnd > seqLen: pEnd = seqLen
    else:
        pEnd = seqLen

    plotLen = pEnd - pStart

    ntPerLine = int(float(options.ntPerLine))
    if ntPerLine > plotLen:
        ntPerLine = plotLen

    l.info("nucleotides per line: %d" % ntPerLine)

    l.info("Plotting from %d to %d (%d nt)" % (
        pStart, pEnd, plotLen))

    r_okh = 0.5 * r_ok

    r_x = np.arange(0, seqLen, dtype="int")
    r_z = np.zeros_like(r_x)

    noLines = int(math.ceil(plotLen / float(ntPerLine)))

    l.info("going to plot %d lines" % noLines)
#    l.info("y axis is between %d and %d" % (minY, maxY))

    mpl.rcParams['axes.labelsize'] = 'x-small'
    mpl.rcParams['xtick.labelsize'] = 'xx-small'
    mpl.rcParams['ytick.labelsize'] = 'xx-small'

    fig = plt.figure(figsize=(10,3*noLines+3))

    _MC = 0.10 - (0.01 * min(8, noLines))
    fig.subplots_adjust(0.03,_MC,0.95,0.95-(2*_MC))

    #calculate intermediate cumilatives
    cumul_high = np.zeros_like(r_high_binned)
    cumul_low = np.zeros_like(r_low_binned)

    for i in range(len(bins_high)):
        if i == 0:
            cumul_high[...,i] = r_okh
        else:
            cumul_high[...,i] = cumul_high[...,i-1] + r_high_binned[...,i]
        
    for i in range(len(bins_low)):
        if i == 0:
            cumul_low[...,i] = -1 * r_okh
        else:
            cumul_low[...,i] = cumul_low[...,i-1] - r_low_binned[...,i]
        
    for line in range(noLines):        
    
        nstart = pStart + (line * ntPerLine)
        nstop = nstart + (ntPerLine - 1)
 
        l.debug('printing line %d from %d to %d' % (
            line, nstart, nstop))

        ax = fig.add_subplot(noLines,1,line+1)
        if line == 0:
            ax.set_title('Coverage plot for "%s" (%d to %d)' % (
                    seqId, pStart, pEnd))

        if options.ymax:
            maxY = int(options.ymax)
            minY = -maxY
        else:
            maxY = int(quant(r_okh[pStart:pEnd], options.yfrac))
            minY = -maxY

        ax.fill_between(
            r_x[nstart:nstop],
            -1 * r_okh[nstart:nstop],
            r_okh[nstart:nstop],
            color="green")
        
        #high's
        l.info("processing %s" % bins_high)
        for i in range(1, len(bins_high)):
            ax.fill_between(
                r_x[nstart:nstop],
                cumul_high[nstart:nstop,i-1],
                cumul_high[nstart:nstop,i],
                color=colHigh(float(i) / len(bins_high)))
        for i in range(1, len(bins_low)):
            ax.fill_between(
                r_x[nstart:nstop],
                cumul_low[nstart:nstop,i-1],
                cumul_low[nstart:nstop,i],
                color=colLow(float(i) / len(bins_high)))

        yAx = ax.get_yaxis()
        yAx.set_ticks(range(minY, maxY, 200))
        ax.set_ylim(2*minY,2*maxY)
        ax.set_xlim(nstart,nstop+1)
        

    if options.outfile:            
        outFileName = options.outfile
    else:
        outFileName = seqId

    if options.start or options.end:
        outFileName += "_%d_%d" % (pStart, pEnd)

    for f in options.format:
        plt.savefig('%s.cbin.%s' % (outFileName, f))

 
