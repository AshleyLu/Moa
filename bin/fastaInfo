#!/usr/bin/env python
# 
# Copyright 2009 Mark Fiers, Plant & Food Research
# 
# This file is part of Moa - http://github.com/mfiers/Moa
# 
# Moa is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your
# option) any later version.
# 
# Moa is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Moa.  If not, see <http://www.gnu.org/licenses/>.
# 

import re
import os
import sys
import math
import site
import math
import tempfile
import optparse

#moa specific libs - first set the path
if not os.environ.has_key('MOABASE'):
    raise Exception("MOABASE is undefined")

#process the .pth file in the $MOABASE/bin folder !
site.addsitedir(os.path.join(os.environ['MOABASE'], 'lib', 'python'))
import moa
import stats.stats as s

parser = optparse.OptionParser()

parser.add_option('-i', dest='infile',
    help = 'input fasta file')
parser.set_defaults(delim="\t")

parser.add_option('-d', dest='delim', help = 'output field delimiter')
parser.add_option('-x', dest='maxno', type='int', 
                  help = 'max no of sequences to process')
parser.add_option('-s', dest='stats', help = 'stats mode - generate averages',
                  action='store_true')
parser.set_defaults(graphengine="R")
parser.add_option('-g', dest='graphengine',
                  help='either "R" or "gnuplot" is used to generated the graphs')
parser.set_defaults(histogramsteps=50)
parser.add_option('-b', dest='histogramsteps', type="int",
                  help='no of bins to use in the histograms')
parser.add_option('-e', dest='echo', action="store_true",
    help = 'echo unknown field ids (as opposed to raise an error)')

(options, args) = parser.parse_args()
if not options.infile:
    raise Exception("Must define an inputfile!")


def fastareader(f):
    F = open(f)
    name, seq = "", []
    while True:
        l = F.readline()
        if not l: break
        
        l = l.strip()
        if not l: continue

        if l[0] == '>':
            if name and seq:
                yield name, "".join(seq)
            seq = []
            name = l[1:]
        else:
            seq.append("".join(l.split()).lower())

    if name and seq:
        yield name, "".join(seq)

    F.close()

i = 0

dd = {}
if options.stats:
    for x in args:
        dd[x] = []

funcs = ['length', 'fracn', 'id', 'scaf10', 'scaf100']

def f_id(name, seq):
    return name.split()[0]

def f_length(name,seq):
    return len(seq)

def f_loglength(name,seq):
    return math.log10(len(seq))

def f_fracn(name, seq):
    return float(seq.count('n')) / len(seq)

def f_gcfrac(name, seq):
    g = seq.count('g')
    c = seq.count('c')
    a = seq.count('a')
    t = seq.count('t')
    return float(g+c) / (g + c + a + t)

scaf10rex = re.compile(r'n{10,}')
scaf100rex = re.compile(r'n{100,}')
def f_scaf10(name,seq):
    return len(scaf10rex.split(seq))

def f_scaf100(name,seq):
    return len(scaf100rex.split(seq))

for name, seq in fastareader(options.infile):
    i += 1
    if options.maxno and i > options.maxno: 
        break

    if options.stats:
        for what in args:
            dd[what].append(eval('f_%s(name, seq)' % what))
    else:
        for what in args:
            if what == "name":
                sys.stdout.write("%s" % name)
            elif what in funcs:
                es = 'f_%s(name, seq)' % what
                v = eval(es)
                sys.stdout.write("%s" % v)
            else:
                if options.echo:
                    sys.stdout.write("%s" % what)
                else:
                    raise Exception("Unknown field %s" % what)
            sys.stdout.write(options.delim)

        sys.stdout.write("\n")


if not options.stats:
    sys.exit(0)

if len(dd) == 0:
    print "no results"
    sys.exit(0)


#start gathering of overall statistics
stats = ['no', 'min', 'max', 'sum', 'mean', 'median',
        'stdev', 'n10', 'n50', 'n90']
data = dict([(x, []) for x in stats])

def statAdd(d,w,v):
    try:
        if abs(v) < 1e-8:
            d[w].append("0       ")
        elif math.log10(abs(v)) > 6:
            d[w].append("%.2e" % v)
        elif v == int(v):
            d[w].append("%d       " % v)
        elif math.log10(abs(v)) < -3:
            d[w].append("%.2e" % v)
        else:
            d[w].append("%.4f  " % v)
    except ValueError:
        print "ERROR"
        print "probably with a math.log10 of something close to 0"
        print d,w,v

def getNX(d, N):
    cutoff = sum(d) * N
    summ = 0
    for x in d:
        result = x
        summ += x
        if summ > cutoff: break
    return result

binsteps = options.histogramsteps

exportData = {}
exportHist = {}
exportHistBin = {}

for what in args:
    d = dd[what]
    if type(d[0]) == type('hi'):
        continue

    #sort & reverse is necessary for the NXX stats
    d.sort()
    d.reverse()
    exportData[what] = d

    _n50 = getNX(d, 0.5)
    _n10 = getNX(d, 0.1)
    _n90 = getNX(d, 0.9)
        
    statAdd(data, 'no', len(d))
    statAdd(data, 'max', d[0])
    statAdd(data, 'min', d[-1])
    statAdd(data, 'sum', sum(d))
    statAdd(data, 'mean', s.mean(d))
    statAdd(data, 'median', s.median(d))
    statAdd(data, 'stdev', s.stdev(d))
    statAdd(data, 'n10', _n10)
    statAdd(data, 'n50', _n50)
    statAdd(data, 'n90', _n90)

    XX = s.histogram(d, binsteps)
    binmin = XX[1]
    binmax = binmin + (XX[2] * len(XX[0]))
    exportHist[what] = XX[0]
    exportHistBin[what] = [binmin + (x * (float(binmax-binmin)/binsteps))
                           for x in range(binsteps+1)]

#print stats to screen
print "".join(["%20s" % x for x in ([""] + args)])
for stat in stats:
    print "".join(["%20s" % x for x in ([stat] + data[stat])])

#write the raw data to file
H,dataFile = tempfile.mkstemp()
F = os.fdopen(H, 'w')
for a in args:
    F.write("%s\t" % a)
F.write("\n")
for i in range(len(exportData[args[0]])):
    for a in args:
        F.write("%g\t" % exportData[a][i])
    F.write("\n")
F.close()

#write the histograms to a file
H,histFile = tempfile.mkstemp()
F = os.fdopen(H, 'w')
for i in range(len(exportHist[args[0]])):
    for a in args:
        F.write("%f\t" % exportHistBin[a][i])
        F.write("%f\t" % exportHist[a][i])
    F.write("\n")
F.close()

print "#export data %s hist %s" % (dataFile, histFile)

filebasename = os.path.basename(options.infile)
if '.' in filebasename:
    filebasename = filebasename[:filebasename.rfind('.')]
    
if options.graphengine.lower() == 'gnuplot':
    #create gnuplot script
    H,plotFile = tempfile.mkstemp()
    F = os.fdopen(H, 'w')
    noplots = len(args)
    F.write('''
    set terminal png nocrop enhanced size 1000,600 
    set output "%(filebasename)s.stat.png"
    set logscale y
    set yrange [0.1:]
    set style fill solid
    set boxwidth 0.9
    set multiplot layout %(noplots)d, 1 title "Stats of %(infilename)s"
    ''' % locals())

    i = 1
    for a in args:
        j = i + 1
        F.write('''
        plot "%(histFile)s" using %(i)d:%(j)d w filledcurve above x1 t "%(a)s"
        ''' % locals())
        i += 2


    F.close()
    os.system("gnuplot %s" % plotFile)

    print "#gnuplot script %s" % (plotFile)
    
elif options.graphengine.lower() == 'r':
    Rscript = '''
        D <- read.table("%(dataFile)s", header=T)
        png("%(filebasename)s.scatter.png", width=900, 700, pointsize=15)    
        plot(D)
        dev.off() ''' % locals()
    for a in args:
        Rscript += '''
        png("%(filebasename)s.%(a)s.png", width=900, 700, pointsize=15)    
        plot(D$%(a)s)
        dev.off() ''' % locals()
    
    H,RFile = tempfile.mkstemp()
    F = os.fdopen(H, 'w')
    F.write(Rscript)
    F.close()
    os.system("R --vanilla < %(RFile)s" % locals())
    print "#R script %s" % (RFile)
