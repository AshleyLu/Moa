#!/usr/bin/env python
# 
# Copyright 2009 Mark Fiers, Plant & Food Research
# 
# This file is part of Moa - http://github.com/mfiers/Moa
# 
# Moa is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your
# option) any later version.
# 
# Moa is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Moa.  If not, see <http://www.gnu.org/licenses/>.
# 

import re
import os
import sys
import math
import site
import math
import tempfile
import optparse

#moa specific libs - first set the path
if not os.environ.has_key('MOABASE'):
    raise Exception("MOABASE is undefined")

#process the .pth file in the $MOABASE/bin folder !
site.addsitedir(os.path.join(os.environ['MOABASE'], 'lib', 'python'))
import moa
import stats.stats as s

parser = optparse.OptionParser()

parser.add_option('-i', dest='infile',
    help = 'input fasta file')
parser.set_defaults(delim="\t")

parser.add_option('-d', dest='delim', help = 'output field delimiter')
parser.add_option('-x', dest='maxno', type='int', 
                  help = 'max no of sequences to process')
parser.add_option('-s', dest='stats', help = 'stats mode - generate averages',
                  action='store_true')
parser.set_defaults(graphengine="R")
parser.add_option('-g' dest='graphengine',
                  help='either "R" or "gnuplot" is used to generated the graphs')
parser.set_defaults(histogramsteps=50)
parser.add_option('-b', dest='histogramsteps', type="int",
                  help='no of bins to use in the histograms')
parser.add_option('-e', dest='echo', action="store_true",
    help = 'echo unknown field ids (as opposed to raise an error)')

(options, args) = parser.parse_args()
if not options.infile:
    raise Exception("Must define an inputfile!")


def fastareader(f):
    F = open(f)
    name, seq = "", []
    while True:
        l = F.readline()
        if not l: break
        
        l = l.strip()
        if not l: continue

        if l[0] == '>':
            if name and seq:
                yield name, "".join(seq)
            seq = []
            name = l[1:]
        else:
            seq.append("".join(l.split()).lower())

    if name and seq:
        yield name, "".join(seq)

    F.close()

i = 0

dd = {}
if options.stats:
    for x in args:
        dd[x] = []

funcs = ['length', 'fracn', 'id', 'scaf10', 'scaf100']

def f_id(name, seq):
    return name.split()[0]

def f_length(name,seq):
    return len(seq)

def f_fracn(name, seq):
    return float(seq.count('n')) / len(seq)

def f_gcfrac(name, seq):
    g = seq.count('g')
    c = seq.count('c')
    a = seq.count('a')
    t = seq.count('t')
    return float(g+c) / (g + c + a + t)

scaf10rex = re.compile(r'n{10,}')
scaf100rex = re.compile(r'n{100,}')
def f_scaf10(name,seq):
    return len(scaf10rex.split(seq))

def f_scaf100(name,seq):
    return len(scaf100rex.split(seq))

for name, seq in fastareader(options.infile):
    i += 1
    if options.maxno and i > options.maxno: 
        break

    if options.stats:
        for what in args:
            dd[what].append(eval('f_%s(name, seq)' % what))
    else:
        for what in args:
            if what == "name":
                sys.stdout.write("%s" % name)
            elif what in funcs:
                es = 'f_%s(name, seq)' % what
                v = eval(es)
                sys.stdout.write("%s" % v)
            else:
                if options.echo:
                    sys.stdout.write("%s" % what)
                else:
                    raise Exception("Unknown field %s" % what)
            sys.stdout.write(options.delim)

        sys.stdout.write("\n")


if not options.stats:
    sys.exit(0)

if len(dd) == 0:
    print "no results"
    sys.exit(0)

print "".join(["%20s" % x for x in ([""] + args)])

stats = ['no', 'min', 'max', 'sum', 'mean', 'median',
        'stdev', 'n10', 'n50', 'n90']
stats += ['binmin', 'binmax']

data = dict([(x, []) for x in stats])

def statAdd(d,w,v):
    try:
        if abs(v) < 1e-8:
            d[w].append("0       ")
        elif math.log10(abs(v)) > 6:
            d[w].append("%.2e" % v)
        elif v == int(v):
            d[w].append("%d       " % v)
        elif math.log10(abs(v)) < -3:
            d[w].append("%.2e" % v)
        else:
            d[w].append("%.4f  " % v)
    except ValueError:
        print "ERROR"
        print "probably with a math.log10 of something close to 0"
        print d,w,v

def getNX(d, N):
    cutoff = sum(d) * N
    summ = 0
    for x in d:
        result = x
        summ += x
        if summ > cutoff: break
    return result

# def getbinrange(min, max, steps):
#     if float(min) / max > 0.2:        
#         expfact = math.floor(math.log10((float(max-min)) / steps))
#         print "%f %f steps %d expfact %f" %( min, max, steps, expfact)
#         sigrs = ((float(max-min)) / steps) / ( 10 ** expfact)
#         if sigrs < 1: newstep = 10 ** expfact
#         elif sigrs < 2: newstep = 2* (10 ** expfact)
#         elif sigrs < 2.5: newstep = 2.5 * (10 ** expfact)
#         elif sigrs < 5: newstep = 5 * (10 ** expfact)
#         else: newstep = 10* (10 ** expfact)
#         newmin = int(min / newstep) * newstep
#         return newmin, newmin + (newstep * steps)
#     else:
#         expfact = math.log10((float(max)) / steps)
#         if expfact > 0: expfact = math.ceil(expfact)
#         else: expfact = math.floor(expfact)
#         sigrs = ((float(max)) / steps) / ( 10 ** expfact)
#         if sigrs < 1: newstep = 10 ** expfact
#         elif sigrs < 2: newstep = 2* (10 ** expfact)
#         elif sigrs < 2.5: newstep = 2.5 * (10 ** expfact)
#         elif sigrs < 5: newstep = 5 * (10 ** expfact)
#         else: newstep = 10* (10 ** expfact)
#         return 0, newstep * steps

binsteps = options.histogramsteps

exportData = {}
exportHist = {}
exportHistBin = {}

for what in args:
    d = dd[what]
    if type(d[0]) == type('hi'):
        continue

    #sort & reverse is necessary for the NXX stats
    d.sort()
    d.reverse()
    exportData[what] = d

    _n50 = getNX(d, 0.5)
    _n10 = getNX(d, 0.1)
    _n90 = getNX(d, 0.9)
        
    statAdd(data, 'no', len(d))
    statAdd(data, 'max', d[0])
    statAdd(data, 'min', d[-1])
    statAdd(data, 'sum', sum(d))
    statAdd(data, 'mean', s.mean(d))
    statAdd(data, 'median', s.median(d))
    statAdd(data, 'stdev', s.stdev(d))
    statAdd(data, 'n10', _n10)
    statAdd(data, 'n50', _n50)
    statAdd(data, 'n90', _n90)

    XX = s.histogram(d, binsteps)
    #print XX
    binmin = XX[1]
    binmax = binmin + (XX[2] * len(XX[0]))
    exportHist[what] = XX[0]
    exportHistBin[what] = [binmin + (x * (float(binmax-binmin)/binsteps))
                           for x in range(binsteps+1)]
    
H,dataFile = tempfile.mkstemp()
F = os.fdopen(H, 'w')
for i in range(len(exportData[args[0]])):
    for a in args:
        F.write("%f\t" % exportData[a][i])
    F.write("\n")
F.close()

H,histFile = tempfile.mkstemp()
F = os.fdopen(H, 'w')
for i in range(len(exportHist[args[0]])):
    for a in args:
        F.write("%f\t" % exportHistBin[a][i])
        F.write("%f\t" % exportHist[a][i])
    F.write("\n")
F.close()

#print stats to screen
for stat in stats:
    print "".join(["%20s" % x for x in ([stat] + data[stat])])

#create gnuplot script
H,plotFile = tempfile.mkstemp()
F = os.fdopen(H, 'w')
noplots = len(args)
infilename = options.infile
filebasename = os.path.basename(infilename)
if '.' in filebasename:
    filebasename = filebasename[:filebasename.rfind('.')]
F.write('''
set terminal png nocrop enhanced size 1000,600 
set output "%(filebasename)s.stat.png"
set logscale y
set yrange [0.1:]
set style fill solid
set boxwidth 0.9
set multiplot layout %(noplots)d, 1 title "Stats of %(infilename)s"
''' % locals())

i = 1
for a in args:
    j = i + 1
    F.write('''
    plot "%(histFile)s" using %(i)d:%(j)d w filledcurve above x1 t "%(a)s"
    ''' % locals())
    i += 2


F.close()
os.system("gnuplot %s" % plotFile)
print "#export data %s hist %s gnuplot %s" % (dataFile, histFile,  plotFile)

#now go for the scatterplots
H,plotFile2 = tempfile.mkstemp()
F = os.fdopen(H, 'w')
noplots = len(args)
infilename = options.infile
filebasename = os.path.basename(infilename)
if '.' in filebasename:
    filebasename = filebasename[:filebasename.rfind('.')]
noargs = len(args)
F.write('''
set terminal png nocrop enhanced size 1000,600 
set output "%(filebasename)s.scat.png"
set xtics font "tiny"
set ytics font "tiny"
set multiplot layout %(noargs)d, %(noargs)d title "scatterplots of %(infilename)s"

''' % locals())

i = 1
for a in range(1, len(args)+1):
    for b in range(1, len(args)+1):
        if a == b:
            currentarg = args[a-1]
            F.write("""
            unset title
            unset xtics
            unset ytics
            unset border
            set label 1 '%(currentarg)s' at 15,15 center 
            plot [10:20] [10:20] sin(x) linecolor 'white' notitle
            """ % locals()) 
        elif a > b:
            F.write("""
            unset title
            unset xtics
            unset ytics
            unset border
            unset label
            plot [10:20] [10:20] sin(x) linecolor 'white' notitle
            """ % locals()) 

        else:
            F.write('''
            unset title
            unset label
            set xtics  font "tiny"
            set ytics font "tiny"
            plot "%(dataFile)s" using %(b)d:%(a)d notitle
            ''' % locals())
        


F.close()
os.system("gnuplot %s" % plotFile2)

print "#export data %s hist %s gnuplot histogram %s scatter %s" % (
    dataFile, histFile,  plotFile, plotFile2)
