#!/usr/bin/env python
#@+leo-ver=4-thin
#@+node:mf.20090529111457.3:@thin bin/lJoin
#@@first
#@@language python
#@+all
#@+node:mf.20090529111457.23:head
#@+node:mf.20090529111457.5:docstring
""" 

A more or less advanced version of the Gnu Join command. It handles more
operators, but is less advanced when it comes to in- and output.

Usage:  lJoin LIST1 OPERATOR LIST2 > OUTPUT
or:     lJoin OPERATOR LIST2 < LIST1 > OUTPUT

This allows chaining of lJoin:

    lJoin LIST1 AND LIST2 | lJoin OR LIST2     

Input:

Two Lists: the field on which the join is performed is *always* the first
    word on the line (delimited by either a tab or space). The rest of the line
    is ignored. 

Operator: AND, OR, DIFFERENCE, INTERSECT

Output: The output is again a list of only the fields that were joined.
"""
#@nonl
#@-node:mf.20090529111457.5:docstring
#@+node:mf.20090529111457.4:imports
import os
import sys
import optparse
import logging
#@-node:mf.20090529111457.4:imports
#@+node:mf.20090529111457.6:optparse
USAGE = "lJoin list1 operator list2"

parser = optparse.OptionParser(usage=USAGE)
parser.set_defaults(verbose=False)
parser.add_option('-v', dest='verbose', help='verbose', 
                  action='store_true')

(options, args) = parser.parse_args()

#@-node:mf.20090529111457.6:optparse
#@+node:mf.20090529111457.7:logging	

if options.verbose:
    loglevel = logging.DEBUG
else:
    loglevel = logging.INFO

logging.basicConfig(
    level=loglevel, 
    format = "#%(message)s")
l = logging
#@-node:mf.20090529111457.7:logging	
#@-node:mf.20090529111457.23:head
#@+node:mf.20090529111457.8:read input

if len(args) == 3:
    list1, operator, list2 = args
    ls1 = set([x.split()[0] for x in open(list1).readlines()])
    l.debug('opened 1: %s with %d items' % (list1, len(ls1)))
else:
    operator, list2 = args
    list1 = 'stdin'
    ls1 = set([x.split()[0] for x in sys.stdin.readlines()])
    l.debug('opened stdin: %s with %d items' % (list1, len(ls1)))

ls2 = set([x.split()[0] for x in open(list2).readlines()])
l.debug('opened 2: %s with %d items' % (list2, len(ls2)))
#@-node:mf.20090529111457.8:read input
#@+node:mf.20090529111457.9:join

if operator.lower() in  ['union', 'or', '|']:
    l.debug("Performing %s | %s" % (list1, list2))
    result = ls1 | ls2
elif operator.lower() in  ['intersect', 'intersection', 'and', '&']:
    l.debug("Performing %s & %s" % (list1, list2))
    result = ls1 & ls2
elif operator.lower() in ['difference', '-']:
    l.debug("Performing %s - %s" % (list1, list2))
    result = ls1 - ls2
#@nonl
#@-node:mf.20090529111457.9:join
#@+node:mf.20090529111457.10:write output
l.debug("Result: %d items" % len(result))

for r in result:
    print r

#@-node:mf.20090529111457.10:write output
#@-all
#@-node:mf.20090529111457.3:@thin bin/lJoin
#@-leo
