#!/usr/bin/env python

import os
import sys

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab

import logging
import optparse
import subprocess

## Arguments: General options 
parser = optparse.OptionParser()
parser.add_option('-v', dest='verbose', action="count", 
                  help='Show debug information')
parser.add_option('-x', dest='limit', type="int",
                  help='Limit the number of pairs to read per input file')
parser.add_option('--skip_step_1' , dest='skip1', action="store_true",
                  help='Skip parsing the BAM files - go to stats directly')

options, args = parser.parse_args()
inputFiles = args
l = logging.getLogger('hagfish')
handler = logging.StreamHandler()
logmark = chr(27) + '[0;37;44mHAGFISH' + \
          chr(27) + '[0m ' 

formatter = logging.Formatter(
    logmark + '%(levelname)-6s %(message)s')

handler.setFormatter(formatter)
l.addHandler(handler)

if options.verbose >= 2:
    l.setLevel(logging.DEBUG)
elif options.verbose == 1:
    l.setLevel(logging.INFO)
else:
    l.setLevel(logging.WARNING)

def run(cl):
    return subprocess.Popen(cl.split(), 
                         stdout=subprocess.PIPE, 
                         stderr=subprocess.PIPE)

def runReturn(cl):
    return run(cl).communicate()[0].split('\n')

def getSequenceInfo(inputFile):
    sequences = {}
    for line in runReturn('samtools view -H %s' % inputFile):
        line = line.strip()
        if not line: continue
        if line[:3] == '@SQ':
            ls = line.split()
            seqId = ls[1][3:]
            seqLen = int(ls[2][3:])
            if not sequences.has_key(seqId):
                sequences[seqId] = {
                    'length' : seqLen,
                    'seenIn' : [inputFile],
                    'start1' : [],
                    'stop1' : [],
                    'start2' : [],
                    'stop2' : [],
                    }
            else:
                if sequences[seqId]['length'] != seqLen:
                    raise(Exception("problem with seqlen"))
                sequences[seqId]['seenIn'].append(inputFile)
    return sequences
    
def readBAM(fileName):
    p = run("samtools view -f 2 %s" % fileName)
    while True:
        line1 = p.stdout.readline()
        if not line1: break
        line1 = line1.strip()
        if not line1: continue
        if line1[0] == '@': continue
        line2 = p.stdout.readline()

        l1 = line1.split()
        l2 = line2.split()

        rl = len(l1[9])
        seqid = l1[2]
        start1 = int(l1[3])
        stop1 = start1 + rl
        start2 = int(l2[3])
        stop2 = start2 + rl

        yield seqid, start1, stop1, start2, stop2, 

def smoother(a, steps):
    result = np.zeros(len(a) - steps + 1)
    for fr in range(steps):
        to = - (steps - fr - 1)
        if to == 0: to = None
        result += a[fr:to]        
    return result / float(steps)

def doStats(bamname, sequences):
    #concatenate all sequences into one
    stats = {}
    insertSizes = np.concatenate(
        [sequences[s]['stop2'] - sequences[s]['start1'] for 
         s in sequences.keys()])
    stats['bamname'] = bamname

    l.info("total no readpairs: %d" % len(insertSizes))
    stats['median'] = np.median(insertSizes)
    stats['average'] = np.average(insertSizes)

    hist, edges = np.histogram(insertSizes, bins=500, range=(0, 30000), new=True)
    mids = 0.5 * (edges[1:] + edges[:-1])

    #smooth by a moving average
    shist = smoother(hist, 10)
    smids = smoother(mids, 10)
    
    top = np.argmax(shist)
    topInsert = smids[top]
    l.info("insert size lies around %s" % topInsert)
    smoothMax = np.max(shist)
    
    leftB = top-1
    while (shist[leftB] > (0.1 * smoothMax)) and \
            (shist[leftB-1] < shist[leftB]) and \
            leftB > 0:
        leftB -= 1
    topLeft = smids[leftB]

    rghtB = top+1
    while (shist[rghtB] > (0.1 * smoothMax)) and \
            (shist[rghtB+1] < shist[rghtB]) and \
            rghtB < len(shist):
        rghtB += 1
    topRight = smids[rghtB]
        
    l.info('plotting figure')
    maxY = np.max(hist) * 1.1
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.vlines(topInsert,0,maxY)
    ax.vlines(topLeft,0,maxY)
    ax.vlines(topRight,0,maxY)
    ax.plot(mids, hist, 'red')
    plt.savefig(os.path.join(bamname + '.hist.png'))

    #write stats file for this library
#    with open(bamname + '.stats') as F:
#        F.write("readpairs %d" % )

def extract(inputFileName):
    l.info('processing BAM file: %s' % inputFileName)
    basename = os.path.basename(inputFileName).replace('.bam', '')
    l.info('Basename %s' % basename)
    sequences = getSequenceInfo(inputFileName)
    for x in sequences.keys():
        l.info('Discovered sequence %s (%d nt)' % (x, sequences[x]['length']))

    limit = options.limit
    if not limit:
        limit = 1e18

    #start processing bam file
    i = 0
    for seqid, start1, stop1, start2, stop2 in readBAM(inputFileName):
        i += 1
        if i > limit: break
        sequences[seqid]['start1'].append(start1)
        sequences[seqid]['stop1'].append(stop1)
        sequences[seqid]['start2'].append(start2)
        sequences[seqid]['stop2'].append(stop2)

    for x in sequences.keys():
        if not os.path.exists(x):
            os.mkdir(x)
        seqdata = sequences[x]
        l.info('Discovered %d pairs for %s' % (len(seqdata['start1']),x))
        seqdata['alldata'] = np.array(
            [ seqdata['start1'],
              seqdata['stop1'],
              seqdata['start2'],
              seqdata['stop2'] 
            ], dtype="uint")

        seqdata['start1'] = np.array(seqdata['start1'])
        seqdata['stop1'] = np.array(seqdata['stop1'])
        seqdata['start2'] = np.array(seqdata['start2'])
        seqdata['stop2'] = np.array(seqdata['stop2'])

        outname = os.path.join(x, basename + '.npy')
        l.info('writing %s ' % outname)
        np.save(outname, seqdata['alldata'])
        l.debug('Done writing output')
    
    #write a list of all known sequences
    with open('seqlist', 'w') as F:
        for s in sequences.keys():
            F.write("%s\n" % s)
        
    doStats(basename, sequences)

if __name__ == '__main__':
    if options.skip1:
        l.info("skipping step 1 -reading older data")
        seqIds = open('seqlist').read().strip().split()    
        l.info("processing %d sequences" % len(seqIds))
        #regenerate the sequences object for each of the 
        for bamfile in open('bamlist').read().strip().split():
            l.info('processing bamfile %s' % bamfile)
            sequences = {}
            for s in seqIds:
                seqData = {}
                datafile = os.path.join(s, bamfile + '.npy')
                seqData['alldata'] = datafile
                data = np.load(datafile)
                l.info('%d records from %s' % (data.shape[1], datafile))
                seqData['start1'] = data[0]
                seqData['stop1'] = data[1]
                seqData['start2'] = data[2]
                seqData['stop2'] = data[3]
                sequences[s] = seqData
            doStats(bamfile, sequences)
    else:
        map(extract, inputFiles)
        with open('bamlist', 'w') as F:
            for i in inputFiles:                
                F.write("%s\n" % os.path.basename(i).replace('.bam', ''))
