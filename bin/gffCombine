#!/usr/bin/env python

help = """
This is a fairly complex, but rather powerfull script. It's can be used to combine 
two gff files into one. Based on selection criteria data from the second gff file
is added to the first.

imagine the following command:
   ./gffcombiner.py 
     -r ../10.getGenes/genes.gff
     -a ../20.getGeneBlast/blastgenes.gff
     -f CDS 
     -c 'note="blastx Swissprot Bacteria"'
     -R '^(?P<ref>\w*)_(?P<start>\d*)_(?P<stop>\d*)\s'
     -X '^.*Hsp_expect=([0-9\.e-]*);.*;Note="(.*)"'
     -Y ';note="Blastx Trembl Bacteria (Eval \1) \2"'
     -o $$base;
     
"""
import re
import os
import sys
import copy
import shlex
import logging
import optparse

parser = optparse.OptionParser()
parser.add_option('-r', '--reference', dest='refgff',
                  help = 'reference gff, to map the other gff file on')
parser.add_option('-a', '--add', dest='addgff',
                  help = 'the gff to add to the reference gff file')
parser.set_defaults(outfile= '-')
parser.add_option('-o', '--output', dest='outfile',
                  help = 'output file, defaults to stdout')

parser.set_defaults(referenceKey='ID')
parser.add_option('-Q', '--referenceKey', dest='referenceKey',
                  help='attribute key to look for in the reference set - based ' + 
                  'this key the reference records to append to are selected (' +
                  'default: ID)')

parser.add_option('-f', '--featureRef', dest='featureRef',
                  help="apply to features of the reference set of this type")
parser.add_option('-s', '--sourceRef', dest='sourceRef',
                  help="apply to features of this source")

parser.add_option('-g', '--featureAdd', dest='featureAdd',
                  help="add only features of type to the reference set")

parser.set_defaults(clearAttribs = [])
parser.add_option('-c', '--clearAttribs', dest='clearAttribs', action="append",
                  help="remove all these attributes from the reference set before adding")

parser.add_option('-R', '--regex', dest='regex',
                  help='regex to apply to each line in the gff to be added' +
                  'to determine how to match the reference gff')                  

parser.set_defaults(appendKey='Note')
parser.add_option('-X', '--appendKey', dest='appendKey',
                  help='Key of the added attribute')

parser.set_defaults(appendVal='"blast hit: %(Note)s"')
parser.add_option('-Y', '--appendVal', dest='appendVal',
                  help='Value of the added attribute')

parser.add_option('-v', '--verbose', dest='verbose', action='store_true',
                  help="verbose output")

#parser.add_option(
(options, args) = parser.parse_args()

if options.verbose:
    logging.basicConfig(level=logging.DEBUG, 
                        format = "%(levelname)s - %(message)s")
else:
    logging.basicConfig(level=logging.INFO, 
                        format = "%(levelname)s - %(message)s")
l = logging 


class DUMMY:
    pass

class GFFRECORD:
    IDFINDER = re.compile(r'ID=([^;]*)')
    def __init__(self, line, clearAttribs = []):
        #see if we can split the line..
        line = line.strip()
        self.line = line
        
        ls = line.split("\t")
        if len(ls) != 9:
            self._type = "string"
        else:
            self._type = "record"
            self.ref = ls[0]
            self.source = ls[1]
            self.feature = ls[2]            
            self.start = ls[3]
            self.stop = ls[4]
            self.score = ls[5]
            self.strand = ls[6]
            self.frame = ls[7]
            self.attriblist = []
            
            lexer = shlex.shlex(ls[8])
            lexer.whitespace=';'
            lexer.whitespace_split=True            
            for token in lexer:
                try:
                    ls = token.split('=', 1)
                    if len(ls) == 1:
                        _key = ls[0]
                        _token = ""
                    else:
                        _key, _val = ls
                except ValueError:
                    l.error("Invalid token '%s'" % token)
                    raise
                except:
                    raise
                if _key not in clearAttribs:
                    self.addAttribute(_key, _val)
                    
    def addAttribute(self, _key, _val):
        """
        Add an attribute to the record
        """
        _key = _key.strip()
        _val = _val.strip()
        if _val[0] in ['"',"'"]: _val = _val[1:]
        if _val[-1] in ['"',"'"]: _val = _val[:-1]
        _val = _val.replace('"',"'")

        if not self.__dict__.has_key(_key):
            self.__dict__[_key] = _val
            self.attriblist.append(_key)
        else:
            if type(self.__dict__[_key]) != type([]):
                self.__dict__[_key] = [self.__dict__[_key], _val]
            else:
                self.__dict__[_key].append(_val)
        
    def __str__(self):
        if self._type == "record":
            a = []
            if 'ID' in self.attriblist:
                a.append('ID=%s' % self.__dict__['ID'])
            for k in self.attriblist:
                if k == 'ID': continue
                v = self.__dict__[k]
                if type(v) == type([]):
                    v = ",".join(v)
                a.append("%s=%s" % (k, v))
            return "\t".join([
                self.ref, self.source, self.feature,
                str(self.start), str(self.stop),
                self.score, self.strand, self.frame,
                ";".join(a)])
        else:
            return self.line
    def pretty(self):
        if self._type != 'record':
            return self.line
        rv = []
        rv.append(" - ".join([self.ref, self.source, self.feature,
                    str(self.start), str(self.stop),
                    self.score, self.strand, self.frame]))
        return "\n".join(rv)
                  
            
        
                

class GFFINDEX:
    def __init__(self, key):
        self.keyName = key
        self.d = {}
        
    def add(self, rec):
        k = rec.__dict__.get(self.keyName, None)
        if not self.d.has_key(k): self.d[k] = []
        self.d[k].append(rec)

    def get(self, k):
        return set(self.d.get(k, []))

    def __str__(self):
        return "index '%s' len: %d" % (self.keyName, len(self.d))
        
class GFFSET:
    def __init__(self, fileName, indici=['ref'], clearAttribs=[]):
        """
        clearAttribs : remove these attributes directly after loading
        """
        
        self.records = []
        self.fileName = fileName
        self.indici = {}
        self.clearAttribs = clearAttribs
        
        for i in indici:
            self.indici[i] = GFFINDEX(i)
            
        for rec in self._gffReader():
            self.addRecord(rec)

    def getRecords(self):
        for r in self.records:
            if r._type == 'record':
                yield r
            
    def addRecord(self, rec):
        self.records.append(rec)
        if rec._type == 'record':
            for i in self.indici.values():
                i.add(rec)
                    
    def report(self):
        l.info("Read %s" % self.fileName)
        l.info("Discovered %d records" % len(self.records))

    def search(self, **kwargs):
        res = None
        for k in kwargs.keys():
            i = self.indici[k]
            if not res: res = i.get(kwargs[k])
            else: res &= i.get(kwargs[k])
            l.debug("res %s -  %s" % (k, len(res)))
        return res
        
    def _gffReader(self):
        F = open(self.fileName, 'r')
        while True:
            line = F.readline()
            if not line: break #EOF
            yield GFFRECORD(line, clearAttribs=self.clearAttribs)
            if line == "##FASTA":
                break

        if line:
            #return the rest of the file.. there appears to be more
            while True:
                line = F.readline()
                if not line: break
                yield GFFRECORD(line, clearAttribs=self.clearAttribs)
        F.close()


l.debug("start loading reference set")
refset = GFFSET(options.refgff, indici=['ID', 'feature', options.referenceKey],
                clearAttribs=options.clearAttribs)
refset.report()

#read the add-to-set
l.debug("start loading the add-set")
addset = GFFSET(options.addgff, indici=['ref'])
addset.report()

querybase = {}
if options.featureRef:
    querybase['feature'] =  options.featureRef
if options.sourceRef:
    querybase['source'] =  options.sourceRef

l.debug("querybase %s" % querybase)

i = 0
appK = options.appendKey

for rec in addset.getRecords():
    if options.featureAdd and rec.feature != options.featureAdd:
        l.debug("ignoring %s" % (str(rec)[:80]))
        continue

    appV = options.appendVal % rec.__dict__
    l.debug("appending %s -  %s" % (appK, appV))

    if i < 100:
        l.debug("%s" % rec)
        for a in rec.attriblist:
            l.debug("  a - %s = %s" % (a, rec.__dict__[a]))

    query = copy.copy(querybase)
    i += 1;
    if i % 180 == 0:
        l.info("processed %d records" % i)

    
    query[options.referenceKey] = rec.ref
    
    l.debug("query %s" % (query))
        
    for r in refset.search(**query):
        r.addAttribute(appK, appV)
        l.debug("appending to")
        l.debug("     %s" % (r.pretty()))

if options.outfile == '-':
    F = sys.stdout
else:
    F = open(options.outfile, 'w')

for r in refset.records:
    F.write("%s\n"%r)

if options.outfile != '-':
    F.close()
    

