#!/usr/bin/env python
"""
Simple command line registry-like system to store variables in a system wide manner

Usage:
    weka set multi.level.name value
    weka get multi.level.name
   
db structure
    w2_key
        id      : int <==+--+
        name    : text   |  |
        parent  : int    |  |
        type_id : int -- +  |
                            |
    w2_value                |
        id      : int       |
        key_id  : int ------+
        value   : text       

"""
import os
import sys
import time
import optparse
import sqlite3

LOG = True

DBRM = [
"""DROP TABLE IF EXISTS w2_key""", 
"""DROP TABLE IF EXISTS w2_value"""
]

DBDEF = [
""" CREATE TABLE IF NOT EXISTS w2_key
	(id INTEGER PRIMARY KEY AUTOINCREMENT,
 	 name text,
         typeid int default 3,
         parentid int,
         FOREIGN KEY (typeid) REFERENCES w2_key(id),
         FOREIGN KEY (parentid) REFERENCES w2_key(id)) """,

""" CREATE INDEX 
        IF NOT EXISTS w2_key_parent_i 
        ON w2_key (parentid)""",

""" CREATE INDEX 
        IF NOT EXISTS w2_key_name_i 
        ON w2_key (name)""",

""" INSERT OR REPLACE INTO w2_key (id, name)
    VALUES (1, 'root') """,

""" INSERT OR REPLACE INTO w2_key (id, name, parentid)
    VALUES (2, 'datatypes', 1) """,

""" INSERT OR REPLACE INTO w2_key (id, name, parentid)
    VALUES (3, 'string', 2) """,

""" CREATE TABLE IF NOT EXISTS w2_value
	(id      INTEGER PRIMARY KEY AUTOINCREMENT,
 	 keyid   INTEGER,
 	 value   TEXT,
         FOREIGN KEY (keyid) REFERENCES w2_key(id)) """,
 
""" CREATE INDEX IF NOT EXISTS w2_value_keyid_i 
        ON w2_value (keyid)""",
]

def l(message):
    if LOG:
        sys.stderr.write("# " + message + "\n")

def error(message):
    print message
    dbConnection.close()
    sys.exit(1)

if not os.environ.has_key("MOABASE"):
    print "MOABASE is not defined"
    exit()

dbLocation = os.path.join(os.environ['MOABASE'], 'var', 'weka.db')

##
#  open dbconn
##
try:
    dbConnection = sqlite3.connect(dbLocation)
except sqlite3.OperationalError:
    error("Cannot open db %s\n" % dbLocation + 
	  "Does the path exists? Do you have write access?")


##
#  initdb
##
c = dbConnection.cursor()
def command_init():
    for statement in DBDEF:
        l("executing %s" % statement)
        c.execute(statement)
    dbConnection.commit()
    c.close()

l("Opened db connection %s " % dbConnection)

##
# runtests
##

if False:
    c = dbConnection.cursor()
    c.execute('''insert into w2_key (name, parentid) VALUES ("hoi1", 1) ''')
    c.execute('''insert into w2_key (name, parentid) VALUES ("hoi2", 2) ''')
    c.execute('''insert into w2_key (name, parentid) VALUES ("hoi3", 3) ''')
    c.execute('''insert into w2_key (name, parentid) VALUES ("hoi4", 4) ''')
    dbConnection.commit
    c.execute('''select * from w2_key''')
    for r in c.fetchall():
        print 'row', r
    sys.exit()

def command_clean():
    l("Cleaning db")
    for statement in DBRM:
        l("executing %s" % statement)
        c.execute(statement)
    dbConnection.commit()
    c.close()

def command_info():
    l("Info")
    sql = "SELECT COUNT(*) from w2_key"
    nokeys = c.execute(sql).fetchone()[0]
    l("no keys: %d" % nokeys)
    sql = "SELECT COUNT(*) from w2_value"
    novalues = c.execute(sql).fetchone()[0]
    l("no values: %d" % novalues)


def key_exists(name, parent_id):
    sql = """SELECT id
               FROM w2_key 
              WHERE name=?
                AND parentid=?"""
    hits = c.execute(sql, ((name, parent_id))).fetchall()
    if len(hits) == 0: return False, 0
    if len(hits) == 1: return True, hits[0][0]
    error("Multiple keys! This should not happen!")

def get_or_create_key(name, parent_id):
    exists, id = key_exists(name, parent_id)
    if exists:
        return id
    sql = """INSERT 
               INTO w2_key (name, parentid)
             VALUES (?, ?) """
    c.execute(sql, ((name, parent_id)))
    newid = c.lastrowid
    dbConnection.commit()
    l("insert new key for %s %s with id %d" % 
      (name, parent_id, newid))
    return newid

def empty_key(key_id):
    """
    Remove all values of a key
    """
    sql = """ DELETE FROM w2_value
               WHERE keyid = ? """
    c.execute(sql, [key_id])
    dbConnection.commit()

def set_value(key_id, value):
    """
    set the value of this key to 'value'
    """
    #first remove all earlier values
    empty_key(key_id)
    sql = """ INSERT INTO w2_value (keyid, value)
             VALUES (?, ?) """
    c.execute(sql, [key_id, value])
    dbConnection.commit()

def command_dump_keys():
    c.execute('select id, name, parentid from w2_key')
    for r in c.fetchall():
        if r[2]:
            print "%d %d %s" % (r[0], r[2], r[1])
        else:
            print "%d - %s" % (r[0], r[1])

def get_values(key_id):
    sql = """SELECT value FROM w2_value 
              WHERE keyid = ? """
    rv = []
    c.execute(sql, [key_id])
    for r in c.fetchall():
        rv.append(r[0])
    return rv

def command_dump(parent=1, tree=[], recursive=True):
    """
    dump the full db
    """
    sql = """ SELECT id, name, parentid
                FROM w2_key
               WHERE parentid = ? """
    c.execute(sql, [parent])
    for row in c.fetchall():
        i = 0
        for v in get_values(row[0]):
            i += 1
            sys.stdout.write(".".join(tree + [row[1]]))
            sys.stdout.write("\t")
            sys.stdout.write("%s\n" % v)
        if i == 0:
            sys.stdout.write(".".join(tree + [row[1]]))
            sys.stdout.write("\n")
            
        if recursive:
            command_dump(parent=row[0],
                         tree = tree + [row[1]],
                         recursive = recursive)
        
def command_set():
    key = sys.argv[2]
    l("setting %s" % (key))
    
    #decompose key
    parent_id = 1
    for component in key.split('.'):
        id = get_or_create_key(component, parent_id)
        parent_id = id
    l("Storing value for key %s with id %d" % 
      (key, id))
    
    if len(sys.argv) > 3:
        set_value(id, sys.argv[3])
            
def command_get():
    key = sys.argv[1]
    get_values

command=sys.argv[1]

if __name__=='__main__':
    if command in ['clean', 'info', 'set', 'dump',
                   'init', 'dump_keys', 'get']:
        eval("command_%s()" % command)

dbConnection.close()
l("exit")
sys.exit(0)
#Main functions
def wekaGet(name, datatype):
	"""
	Get a variable from the database	
	"""
	c = dbConnection.cursor()
	if options.showAll == 0:
		sql = """	
			SELECT value, created, archived 
			  FROM vars 
f			 WHERE name = ?
			   AND datatype = ? 
			   AND archived = 0
		  ORDER BY created DESC
		     LIMIT 1 """
	elif options.showAll == 1:
		sql = """   
			SELECT value, created, archived 
			  FROM vars 
			 WHERE name = ? 
			   AND datatype = ?
			   AND archived = 0
		  ORDER BY created DESC """
	else:
	 	sql = """   
 			SELECT value, created, archived 
			  FROM vars 
			 WHERE name = ? 
			   AND datatype = ?
		  ORDER BY created DESC """

	log("executing %s with %s" % (sql, [name, datatype]))
	c.execute(sql,[name, datatype])

	i = 0

	headers = []
	if options.verbose > 1:
		headers.append(("", "%1s"))
	if options.verbose > 0:
		if options.showUnixTime:
			headers.append(("unix time", "%-11s"))
		else:
			headers.append(("time", "%-26s"))
	headers.append(("value", "%-s"))
	outputHeaders(headers)

	for rec in c.fetchall():		
		rv = []			
		i += 1	

		if options.verbose > 0 and options.showAll > 1:
			if rec[2] == 0: rv.append("+")
			else: rv.append("d")
		if options.verbose > 0 and options.showAll > 0:	 	
			if options.showUnixTime: rv.append(rec[1])
			else: rv.append(time2str(rec[1]))
		rv.append(rec[0])
		outputF(rv, headers)			

	#if not options.showAll and i == 0:
	#	#expecting something & got nothing.. return error
	#	error("Cannot find %s.%s" % (datatype, name))
	if options.verbose > 0:
		outputFooter("d = deleted, + = active")

def wekaLs(*args):
	"""show a list of all vars in the db"""
	c = dbConnection.cursor()
	if options.showAll == 0:
		sql = """
			SELECT DISTINCT datatype, name, 1
		  	  FROM vars
		  	 WHERE archived = 0 """
	elif options.showAll == 1:
		sql = """
			SELECT DISTINCT datatype, name, count(name)
		  	  FROM vars
		  	 WHERE archived = 0
	  	  GROUP BY datatype, name """
	else:
		sql = """
			SELECT DISTINCT datatype, name, count(name)
		  	  FROM vars
	  	  GROUP BY datatype, name """

	log("executing %s" % sql)
	c.execute(sql)

	if options.verbose == 0:
		headers = [("name.datatype", "%s")]
	else:
		headers = [("count", "%5s"), ("name.datatype", "%s")]

	outputHeaders(headers)

	for rec in c.fetchall():
		rv = []
		if options.verbose:
			rv.append(rec[2])
		rv.append("%s::%s" % (rec[1], rec[0]))
		outputF(rv, headers)

def wekaSet(name, datatype, value):
	"""Get a var from the db"""
	c = dbConnection.cursor()
	if options.replace:
		sql = """
			UPDATE vars
			   SET archived = 1
			 WHERE name = ?
			   AND datatype = ? """
		log("executing %s with %s" % (sql, [name, datatype]))
		c.execute(sql, [name, datatype])

	sql = """		
		INSERT INTO vars (name, datatype, value)
			 VALUES (?, ?, ?)"""

	log("executing %s with %s" % (sql, [name, datatype, value]))
	c.execute(sql, [name, datatype, value])
	dbConnection.commit()	

def wekaRm(datatype = None, name = None):
	"""completely remove a var from the db"""
	c = dbConnection.cursor()
	if datatype and name:
		log("Removing %s/%s" % (datatype, name))
		sql = """DELETE FROM vars 
				       WHERE name = ?
						 AND datatype = ?"""
		log("Executing %s with %s" % (sql, [name, datatype]))
		c.execute(sql, [name, datatype])
		dbConnection.commit()	
	elif name:
		log("Removing {ALL}/%s" % (name))
		sql = "DELETE FROM vars WHERE name = ?"
		log("Executing %s with %s" % (sql, [name]))
		c.execute(sql, [name])
		dbConnection.commit()	



	#read commandline and act!

	if command == "set":	
		if len(args) != 3:			
			error("invalid number of arguments")
		name, datatype = args[1].split('::')		
		value = args[2]
		wekaSet(name = name, 
				  datatype = datatype, 
				  value = value)

	elif command == "get":
		if len(args) != 2:
			error("invalid number of arguments")
		name, datatype = args[1].split('::')
		wekaGet(name, datatype)

	elif command == "ls":
		wekaLs(args[1:])

	elif command == "rm":
		if len(args) != 2:
			error("invalid number of arguments")			
		if '.' in args[1]:
			name, datatype = args[1].split('::')
		else:			
			name = args[1]
			datatype = None

		wekaRm(datatype = datatype, 
			 	 name = name)		
	else:
		usage()
		error("Invalid command %s" % command)

