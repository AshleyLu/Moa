#!/usr/bin/env python
"""
Simple command line registry-like system to store variables in a system wide manner

Usage:
    weka set multi.level.name value
    weka get multi.level.name
   
db structure
    w2_key
        id      : int <==+--+
        name    : text   |  |
        parent  : int    |  |
        type_id : int -- +  |
                            |
    w2_value                |
        id      : int       |
        key_id  : int ------+
        value   : text       

"""
import os
import sys
import time
import optparse
import sqlite3
import socket
import logging
    
LOG = True

#Set optparse
oparser = optparse.OptionParser()
oparser.add_option("-v", dest="verbose", action="store_true")

options, args = oparser.parse_args()

logFormat = "## %(name)s %(levelname)s - %(message)s"
if options.verbose:
    logging.basicConfig(level=logging.WARNING,
                        format=logFormat)
else:
    logging.basicConfig(level=logging.DEBUG,
                        format=logFormat)

l = logging.getLogger("weka2")

## Helper functions
def DBRM():
    """ Return a list of sql statements to remove the weka2 db """

    return [ 
        """DROP TABLE IF EXISTS w2_key""", 
        """DROP TABLE IF EXISTS w2_value""" 
        ]

def DBDEF():
    """ Return a list of sql statements to create the weka2 db """

    return [
        """ CREATE TABLE IF NOT EXISTS w2_key
                (id INTEGER PRIMARY KEY AUTOINCREMENT,
                 name text,
                 typeid int default 3,
                 parentid int,
                 FOREIGN KEY (typeid) REFERENCES w2_key(id),
                 FOREIGN KEY (parentid) REFERENCES w2_key(id)) """,
        """ CREATE INDEX 
                IF NOT EXISTS w2_key_parent_i 
                ON w2_key (parentid)""",

        """ CREATE INDEX 
                IF NOT EXISTS w2_key_name_i 
                ON w2_key (name)""",

        """ INSERT OR REPLACE INTO w2_key (id, name)
            VALUES (1, 'root') """,

        """ INSERT OR REPLACE INTO w2_key (id, name, parentid)
            VALUES (2, 'datatypes', 1) """,

        """ INSERT OR REPLACE INTO w2_key (id, name, parentid)
            VALUES (3, 'string', 2) """,

        """ CREATE TABLE IF NOT EXISTS w2_value
                (id      INTEGER PRIMARY KEY AUTOINCREMENT,
                 keyid   INTEGER,
                 value   TEXT,
                 FOREIGN KEY (keyid) REFERENCES w2_key(id)) """,

        """ CREATE INDEX IF NOT EXISTS w2_value_keyid_i 
                ON w2_value (keyid)""",
        ]

def getDbLocation():
    """ Get the location of the weka2 database """

    if not os.environ.has_key("MOABASE"):
        raise Exception("MOABASE environment variable is Undefined")
    return os.path.join(os.environ['MOABASE'], 'var', 'weka.db')

def error(message):
    print message
    dbConnection.close()
    sys.exit(1)


def key_exists(name, parent_id):
    sql = """SELECT id
               FROM w2_key 
              WHERE name=?
                AND parentid=?"""
    hits = c.execute(sql, ((name, parent_id))).fetchall()
    if len(hits) == 0: return False, 0
    if len(hits) == 1: return True, hits[0][0]
    error("Multiple keys! This should not happen!")

def get_or_create_key(name, parent_id):
    exists, id = key_exists(name, parent_id)
    if exists:
        return id
    sql = """INSERT 
               INTO w2_key (name, parentid)
             VALUES (?, ?) """
    c.execute(sql, ((name, parent_id)))
    newid = c.lastrowid
    dbConnection.commit()
    l.debug("insert new key for %s %s with id %d" % 
      (name, parent_id, newid))
    return newid

def empty_key(key_id):
    """
    Remove all values of a key
    """
    sql = """ DELETE FROM w2_value
               WHERE keyid = ? """
    c.execute(sql, [key_id])
    dbConnection.commit()

def set_value(key_id, value):
    """
    set the value of this key to 'value'
    """
    #first remove all earlier values
    empty_key(key_id)
    sql = """ INSERT INTO w2_value (keyid, value)
             VALUES (?, ?) """
    c.execute(sql, [key_id, value])
    dbConnection.commit()

#command definitions

def command_init():
    for statement in DBDEF():
        l.debug("executing %s" % statement)
        c.execute(statement)
    dbConnection.commit()
    c.close()

def command_clean():
    l.debug("Cleaning db")
    for statement in DBRM():
        l.debug("executing %s" % statement)
        c.execute(statement)
    dbConnection.commit()
    c.close()

def command_info():
    l.debug("Info")
    sql = "SELECT COUNT(*) from w2_key"
    nokeys = c.execute(sql).fetchone()[0]
    l.debug("no keys: %d" % nokeys)
    sql = "SELECT COUNT(*) from w2_value"
    novalues = c.execute(sql).fetchone()[0]
    l.debug("no values: %d" % novalues)

def command_dump_keys():
    c.execute('select id, name, parentid from w2_key')
    for r in c.fetchall():
        if r[2]:
            print "%d %d %s" % (r[0], r[2], r[1])
        else:
            print "%d - %s" % (r[0], r[1])

def get_values(key_id):
    sql = """SELECT value FROM w2_value 
              WHERE keyid = ? """
    rv = []
    c.execute(sql, [key_id])
    for r in c.fetchall():
        rv.append(r[0])
    return rv

def command_dump(args=None, parent=1, tree=[], recursive=True):
    """
    dump the full db
    
    no arguments (args) are expected.
    """
    rv = []
    sql = """ SELECT id, name, parentid
                FROM w2_key
               WHERE parentid = ? """
    c.execute(sql, [parent])
    for row in c.fetchall():
        i = 0
        for v in get_values(row[0]):
            i += 1
            rv.append(".".join(tree + [row[1]]))
            rv.append("\t")
            rv.append("%s\n" % v)
        if i == 0:
            rv.append(".".join(tree + [row[1]]))
            rv.append("\n")
            
        if recursive:
            rv.append(command_dump(parent=row[0],
                                   tree = tree + [row[1]],
                                   recursive = recursive))
        l.debug("about to dump %s" % rv)
        return "".join(["%s" % x for x in rv])

def command_set():
    key = sys.argv[2]
    l.debug("setting %s" % (key))
    
    #decompose key
    parent_id = 1
    for component in key.split('.'):
        id = get_or_create_key(component, parent_id)
        parent_id = id
    l.debug("Storing value for key %s with id %d" % 
      (key, id))
    
    if len(sys.argv) > 3:
        set_value(id, sys.argv[3])
            
def command_get():
    key = sys.argv[1]
    get_values


SOCK = None
ARGS = []
#Initialize application

if not os.environ.has_key("MOABASE"):
    print "MOABASE is not defined"
    exit()


#see if there is a server running..
server_pid = os.path.join(os.environ['MOABASE'], 'var', 'weka.pid')
newpid = None
SOCK = socket.socket(socket.AF_INET,
                     socket.SOCK_DGRAM)

def call_server(args):
    l.debug("connecting to server")
    SOCK.connect(('localhost', 18981))
    send_args = "::".join(args)
    l.debug('start sending arguments "%s"' % send_args)
    SOCK.sendall(send_args)
    l.debug("finished sending arguments")
    data = SOCK.recvfrom(1024)
    return data

if not os.path.exists(server_pid):
    #Fork off a server
    newpid = os.fork()
    l = logging.getLogger("-weka2c")
    if newpid == 0:
        #this is the child (= client) process, call the server.
        l.debug("client calls server")
        call_server(sys.argv[1:])
        l.debug("end call to server")
        sys.exit()
else:
    #server does already exists. call it.
    #this is the child (= client) process, call the server.
    call_server(sys.argv[1:])

#if we're here... we'll start a server
l = logging.getLogger("#weka2S")
l.debug("start weka2 server")
SOCK.bind(('localhost', 18981))
l.debug("succes binding server to localhost 18981")

##
#  open dbconn
##
try:
    dbConnection = sqlite3.connect(getDbLocation())
except sqlite3.OperationalError:
    error("Cannot open db %s\n" % dbLocation + 
	  "Does the path exist? Do you have write access?")

c = dbConnection.cursor()

#server loop
while True:
    data, from_address = SOCK.recvfrom(1024)
    l.debug("server received data %s from %s" % (data, from_address))
    ls = data.split("::")
    command = ls[0]
    l.debug("server command %s" % (command))
    command_args = ls[1:]
    RSOCK =  socket.socket(socket.AF_INET,
                           socket.SOCK_DGRAM)
    RSOCK.connect(from_address)
    if command in ['clean', 'info', 'set', 'dump',
                   'init', 'dump_keys', 'get',]:
        command = "command_%s(args=command_args)" % command
        l.debug("executing %s with args %s" % (command, command_args))
        
        RSOCK.sendall(eval(command))
        l.debug("Done executing command")
    RSOCK.close()


dbConnection.close()
l.debug("exit")
sys.exit(0)
