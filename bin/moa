#!/usr/bin/env python
# 
# Copyright 2009, 2010 Mark Fiers, Plant & Food Research
# 
# This file is part of Moa - http://github.com/mfiers/Moa
# 
# Moa is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your
# option) any later version.
# 
# Moa is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Moa.  If not, see <http://www.gnu.org/licenses/>.
# 
"""
Moa executable

This script is a command dispatcher for all Moa functionality.

"""

import os
import sys
import optparse
import textwrap

#moa specific libs
import moa.job
import moa.utils
import moa.version
import moa.project
import moa.plugin
import moa.commands

#the system configuration is available as a global from the
#sysConf module
from moa.sysConf import sysConf

## Initialize the logger
import moa.logger as l

## A hack to set verbosity before reading command line arguments
if '-v' in sys.argv:
    moa.logger.setVerbose()

## Initialze the plugins
plugins = moa.plugin.PluginHandler(sysConf)

## Command definitions
sysConf.commands = moa.commands.Commands()
plugins.run('defineCommands')

## defining a usage message
USAGE = "Usage: {{bold}}{{green}}%prog {{blue}}[options] COMMAND ARGUMENTS{{reset}}\n\n"
moaCommandNames = sysConf.commands.keys()
moaCommandNames.sort()

commandsG = []
commandsJ = []

for _c in moaCommandNames:
    if sysConf.commands[_c].get('private', False):
        continue
    if sysConf.commands[_c].get('needsJob',  True):
        commandsJ.append([_c, sysConf.commands[_c]['desc']])
    else:
        commandsG.append([_c, sysConf.commands[_c]['desc']])

commandsG.sort()
commandsJ.sort()
USAGE += "Universal Moa commands:\n"
for c, d in commandsG:
    USAGE += "\n".join(
        textwrap.wrap(
            '{{bold}}%15s{{reset}} : %s' % (c, d),
            initial_indent=' ',
            subsequent_indent = ' ' * 19)) + "\n"

USAGE += "\nJob specific Moa commands:\n"
for c,d  in commandsJ:
    USAGE += "\n".join(
        textwrap.wrap(
            '{{bold}}%15s{{reset}} : %s' % (c, d),
            initial_indent=' ',
            subsequent_indent = ' ' * 19)) + "\n"


## define & parse command line options  
parser = optparse.OptionParser(usage=moa.ui.fformat(USAGE, f='jinja'))

parser.add_option(
    '-f', '--force', dest='force', action='store_true',
    help='Force an action, if applicable.')

parser.add_option(
    "-v", "--verbose", dest="verbose", action="store_true",
    help="Verbose output")

parser.add_option(
    "-s", "--silent", dest="silent", action="store_true",
    help="Be very silent")

parser.add_option(
    "--bg", dest="background", action="store_true",
    help="Run moa in the background (implies -s)")

parser.add_option("-r", "--recursive", dest="recursive",
                  help="Perfom action recursively", action='store_true')

## See if the plugins have anything to add to the optparse instance:
sysConf.parser = parser
plugins.run('defineOptions')

def run2(job, command):

    if command in sysConf.commands:
        if not sysConf.commands[command].has_key('call'):
            moa.ui.exitError("Invalid command - no callback %s" % command) 

        l.debug("using a callback for moa %s" % command)
        try:
            plugins.runCallback(job, command)
            rc = 0
        except:
            #this should not happen!!
            rc = -1
            sysConf.rc = rc                    
            raise
        
        return rc
    
    #No callback, defer this to the backend
    rc = job.execute(command,
        verbose = options.verbose,
        silent = options.silent)
    
    return rc

def run(job, command):

    ## Ask the job if it's is ok with
    ## the command provided (might want to change order, or insert
    ## stuff
    execList = job.checkCommands(command)
    sysConf.executeCommand = execList

    l.debug("Run moa commands: %s" % ",".join(execList))
    l.debug("with args %s" % newargs)

    ### Start job initialization
    job.prepare()

    ### Start plugin initialization
    plugins.run('prepare')

    #see if there is a callback to a plugin - If so call it

    plugins.run("preCommand")
    if command not in execList:
        plugins.run("pre%s" % command.capitalize())

    for execNow in execList:
        l.debug("Executing %s" % execNow)                
        plugins.run("pre%s" % execNow.capitalize())

        rc = run2(job, execNow)

        sysConf.rc = rc
        plugins.run("post%s" % execNow.capitalize(), reverse=True)

    if command not in execList:
        plugins.run("post%s" % command.capitalize(), reverse=True)

    plugins.run("postCommand", reverse=True)
    plugins.run("finish", reverse=True)
    return rc
    
## Main dispatcher
if __name__ == "__main__":
    try:        
        wd = os.getcwd()
        
        #sysConf.wd = wd
        #sysConf.cwd = wd #deprecated...

        job = moa.job.Job(wd)

        ## Aks the job & backend if they want to add to the options
        job.defineOptions(parser)
        
        ## Parse the options
        (options, args) = parser.parse_args()

        ## make sure that the options are accessible to the plugins
        sysConf.options = options
        sysConf.args = args
        sysConf.job = job

        ## Proper setting of verbosity - after parsing of the command line
        if options.verbose:
            moa.logger.setVerbose()

        ## Determine command to run:
        if len(args) > 0:
            command = args[0]
            newargs = args[1:]
        else:
            command = 'status'
            newargs

        sysConf.newargs = newargs
        sysConf.originalCommand = command        
        moa.version.fixOld(wd)

        #first see if we need to fork - if this is a background job
        if options.background:
            options.silent = True
            child = os.fork()
            if child != 0:
                # This is the parent thread - exit now - all
                sysConf.childPid = child
                plugins.run("bgParentExit")
                moa.ui.fprint("starting background run")
                sys.exit(0)


        def _recursiveRun(job, command):
            #turn of recursive - no recursively run recursive jobs
            sysConf.options.recursive = False
            rc = 0            
            for path, dirs, files in os.walk(job.wd):
                if '.moa' in dirs:
                    rjob = moa.job.Job(path)                    
                    moa.ui.fprint("Executing 'moa %s' in %s" % (
                        command, path))
                    rc += abs(run(rjob, command))

                #remove all '.' directories -
                drem = [ x for x in dirs if x[0] == '.' ]
                [ dirs.remove(t) for t in drem]
            return rc
                  

        if sysConf.options.recursive:
            if command in sysConf.commands:
                rcmode = sysConf.commands[command].get('recursive', 'none')
                if  rcmode == 'local':
                    #local recursive mode - recursive operation
                    #is implemented at the command level
                    run(job, command)
                elif rcmode == 'none':
                    moa.ui.exitError("Cannot run recursive run 'moa %s'")
                else:
                    moa.ui.fprint("Start recursive 'moa %s'" % command,
                                  f='jinja')
                    rc = _recursiveRun(job, command)
            else:
                #not command in sysConf.commands - it is not a callback
                #but will be deferred to the backend -
                #always recusively:
                rc = _recursiveRun(job, command)
        else:
            #non recursive - just run the command
            rc = run(job, command)

    except KeyboardInterrupt:
        sysConf.rc = -1
        plugins.run("postInterrupt")
        moa.ui.warn("Interrupted")
        sys.exit(-1)
