#!/usr/bin/env python
# 
# Copyright 2009, 2010 Mark Fiers, Plant & Food Research
# 
# This file is part of Moa - http://github.com/mfiers/Moa
# 
# Moa is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your
# option) any later version.
# 
# Moa is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Moa.  If not, see <http://www.gnu.org/licenses/>.
# 
"""
Moa executable

This script is a command dispatcher for all Moa functionality.

"""

import os
import sys
import optparse
import textwrap

#moa specific libs
import moa.job
import moa.utils
import moa.version
import moa.project
import moa.plugin
import moa.commands

from moa.sysConf import sysConf


## Initialize the logger
import moa.logger as l

## A hack to set verbosity before reading command line arguments
if '-v' in sys.argv:
    moa.logger.setVerbose()

## Initialze the plugins
plugins = moa.plugin.PluginHandler(sysConf.getPlugins())

# Initialize the job object
wd = os.getcwd()
moa.version.fixOld(wd)
job = moa.job.Job(wd)
job.plugins = plugins
    
#use of cwd is deprecated
plugins.register(cwd = wd)
plugins.register(sysConf = sysConf)
plugins.register(wd = wd)
plugins.register(job = job)

### Determine project root (if there is one)
#projectRoot = moa.project.findProjectRoot(job)
#if projectRoot:
#    l.debug('Project root is %s' % projectRoot)
#    job.projectRoot = projectRoot
#    plugins.register(projectRoot = projectRoot)

## Command definitions
moaCommands = moa.commands.Commands()
plugins.register(commands = moaCommands)
plugins.run('defineCommands')


## start defining the command line interface
USAGE = "Usage: {{bold}}{{green}}%prog {{blue}}[options] COMMAND ARGUMENTS{{reset}}\n\n"
moaCommandNames = moaCommands.keys()
moaCommandNames.sort()

commandsG = []
commandsJ = []

for _c in moaCommandNames:
    if moaCommands[_c].get('private', False):
        continue
    if moaCommands[_c].get('needsJob',  True):
        commandsJ.append([_c, moaCommands[_c]['desc']])
    else:
        commandsG.append([_c, moaCommands[_c]['desc']])

commandsG.sort()
commandsJ.sort()
USAGE += "Universal Moa commands:\n"
for c, d in commandsG:
    USAGE += "\n".join(
        textwrap.wrap(
            '{{bold}}%15s{{reset}} : %s' % (c, d),
            initial_indent=' ',
            subsequent_indent = ' ' * 19)) + "\n"

USAGE += "\nJob specific Moa commands:\n"
for c,d  in commandsJ:
    USAGE += "\n".join(
        textwrap.wrap(
            '{{bold}}%15s{{reset}} : %s' % (c, d),
            initial_indent=' ',
            subsequent_indent = ' ' * 19)) + "\n"


## define & parse command line options  
parser = optparse.OptionParser(usage=moa.ui.fformat(USAGE, f='jinja'))

parser.add_option(
    '-f', '--force', dest='force', action='store_true',
    help='Force an action, if applicable.')

parser.add_option(
    "-v", "--verbose", dest="verbose", action="store_true",
    help="Verbose output")

parser.add_option(
    "-s", "--silent", dest="silent", action="store_true",
    help="Be very silent")

parser.add_option(
    "--bg", dest="background", action="store_true",
    help="Run moa in the background (implies -s)")

def run():

    ## Aks the job & backend if they want to add to the options
    job.defineOptions(parser)

    ## See if the plugins have anything to add to the optparse instance:
    plugins.register(parser=parser)
    plugins.register(commands=moaCommands)
    plugins.run('defineOptions')

    ## Parse the options
    (options, args) = parser.parse_args()

    ## make sure that the options are accessible to the plugins
    plugins.register(options = options, args = args)
    job.options = options
    job.args = args

    ## Proper setting of verbosity - after parsing of the command line
    if options.verbose:
        moa.logger.setVerbose()

    ## Determine command to run:
    command = ""
    newargs = []
    
    if len(args) > 0:
        commands = [args[0]]
        newargs = args[1:]
    else:
        commands = ['status']

    originalCommand = commands[0]
    plugins.register(executeCommand=commands)
    plugins.register(originalCommand=commands[0])

    ## Ask the job if it's is ok with
    ## these commands (might want to change order, or insert
    ## stuff
    commands = job.checkCommands(commands)

    l.debug("Run moa commands: %s" % ",".join(commands))
    l.debug("with args %s" % newargs)

    plugins.register(newargs = newargs)
    job.args = newargs

    ### Start job initialization
    job.prepare()

    ### Start plugin initialization
    plugins.run('prepare')

    #see if there is a callback to a plugin - If so call it
    
    for command in commands:

        plugins.run("preCommand")
        plugins.run("pre%s" % originalCommand.capitalize())

        if command in moaCommands:
            if moaCommands[command].has_key('call'):
                l.debug("using a callback for moa %s" % command)
                try:
                    plugins.runCallback(moaCommands[command])
                    rc = 0
                except:
                    rc = -1
                    plugins.register(rc = rc)
                    plugins.run("post%s" % command.capitalize())
                    plugins.run("postCommand")
                    raise
        else:
            #No callback, defer this to the job

            #first see if we need to fork - if this is a background job
            if options.background:
                options.silent = True
                child = os.fork()
                if child != 0:
                    # This is the parent thread - exit now - all
                    plugins.register(childPid = child)
                    plugins.run("bgParentExit")
                    moa.ui.fprint("Running in the background")
                    sys.exit(0)

            rc = job.execute(
                command,
                verbose = options.verbose,
                silent = options.silent)
            
        plugins.register(rc = rc)
        plugins.run("post%s" % originalCommand.capitalize())
        plugins.run("postCommand")        

    plugins.run("finish")
    sys.exit(rc)

    
## Command dispatcher
if __name__ == "__main__":
    try:
        run()
    except KeyboardInterrupt:
        plugins.register(rc = -1)
        plugins.run("postInterrupt")
        moa.ui.warn("Interrupted")
        sys.exit(-1)
